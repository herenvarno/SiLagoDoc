{
    "docs": [
        {
            "location": "/",
            "text": "Warning\n\n\nDocumentation is not complete!\n\n\n\n\nWelcome to SiLago Documentation\n\u00b6\n\n\nAvailable docs\n\u00b6\n\n\n\n\nFabric\n\n\nManus code tutorial\n\n\nVesyla tutorial",
            "title": "Home"
        },
        {
            "location": "/#welcome-to-silago-documentation",
            "text": "",
            "title": "Welcome to SiLago Documentation"
        },
        {
            "location": "/#available-docs",
            "text": "Fabric  Manus code tutorial  Vesyla tutorial",
            "title": "Available docs"
        },
        {
            "location": "/Fabric/",
            "text": "Fabric\n\u00b6\n\n\nPlease check the specification of DRRA: \nDRRA Specification",
            "title": "Fabric"
        },
        {
            "location": "/Fabric/#fabric",
            "text": "Please check the specification of DRRA:  DRRA Specification",
            "title": "Fabric"
        },
        {
            "location": "/Compiler/Overview/",
            "text": "Warning\n\n\nDocumentation is not complete!",
            "title": "Overview"
        },
        {
            "location": "/Compiler/Manus/",
            "text": "Manus code\n\u00b6\n\n\nStructure\n\u00b6\n\n\nManus code is a kind of text-based assembly language for SiLago platform. Manus code is caseless.\n\n\nSegment\n\u00b6\n\n\nManus code consists of segments. Two type of segments are valid in Manus code. They are \nDATA SEGMENT\n and \nCODE SEGMENT\n which are marked by \n.DATA\n and \n.CODE\n respectively. All the contents following a segment mark belong to that specific segment.\n\n\nDATA SEGMENT\n is used for declare and initialize variables in register file, while \nCODE SEGMENT\n is used for assign instructions to \nsequencer\n of each DRRA cell.\n\n\nVariable\n\u00b6\n\n\nVariables should be defined in \nDATA SEGMENT\n. The defination format is:\n\n\n$variable_name distribution_type [<row0, col0>, <row1, col1>, ...] [element0, element1, ...]\n\n\nor\n\n\n$variable_name distribution_type [<row0, col0>, <row1, col1>, ...] ZEROS(number_of_element)\n\n\nor\n\n\n$variable_name distribution_type [<row0, col0>, <row1, col1>, ...] ONES(number_of_element)\n\n\nVariable name should always be led by a dollar (\n$\n) symbol. The first symbol after dollar (\n$\n) should only be underscore ( \n_\n ) or regular latin letter (a-z, A-Z). The following symbol can be underscore ( \n_\n ), regular latin letter (a-z, A-Z) as well as number (0-9).\n\n\nDistribution type can be either \nFULL_DISTR\n or \nEVEN_DIRSR\n.\n\n\nThe third argument is a list of DRRA cells.\n\n\nThe last argument is the list of initial value of each element inside the variable.\n\n\nAll variable are considered as a 1-D array in register file.\n\n\nDRRA cell\n\u00b6\n\n\nTo specify a DRRA cell for following instructions, use:\n\n\nCELL <row, col>\n\n\nInstructions\n\u00b6\n\n\nInstructions should be defined in \nCODE SEGMENT\n. The defination format is:\n\n\ninstruction_name arg0 arg1 ...\n\n\nor\n\n\ninstruction_name arg0, arg1, ...\n\n\nSee next section for various instruction defination detail.\n\n\nInstructions set\n\u00b6\n\n\n0001 - REFI1\n\u00b6\n\n\n26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  0  0  1  A  A  B  B  C  D  D  D  D  D  D  E  F  F  F  F  F  F  G  H  H  H  H\n\n\n\n\n\n\n\n\n\n\nField\n\n\nPosition\n\n\nWidth\n\n\nRange/Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninstr_code\n\n\n[26, 23]\n\n\n4\n\n\nb'0001\n\n\nREFI1 instruction code\n\n\n\n\n\n\nreg_file_port\n\n\n[22, 21]\n\n\n2\n\n\n[0, 3]\n\n\nSelects one of the RFile ports\n\n\n\n\n\n\nsubseq_instrs\n\n\n[20, 19]\n\n\n2\n\n\n[0, 3]\n\n\nThe instruction decoder fetches the consequent (REFI1) or (REFI1 and REFI2) instructions.\n\n\n\n\n\n\nstart_addrs_sd\n\n\n18\n\n\n1\n\n\n[0, 1]\n\n\nThe start_addrs is valid only if the start_addrs_sd is 0. Otherwise the start_address would be taken from the RACCU register\n\n\n\n\n\n\nstart_addrs\n\n\n[17, 12]\n\n\n6\n\n\n[0, 63]\n\n\nConfigures the starting address for the AGU\n\n\n\n\n\n\nno_of_addrs_sd\n\n\n11\n\n\n1\n\n\n[0, 1]\n\n\nThe no_of_addrs is valid only when no_of_addrs_sd is 0, otherwise the no_of_addrs would be taken from the RACCU register.\n\n\n\n\n\n\nno_of_addrs\n\n\n[10, 5]\n\n\n6\n\n\n[0, 63]\n\n\nConfigures the number of address for the AGU\n\n\n\n\n\n\ninitial_delay_sd:\n\n\n4\n\n\n1\n\n\n[0, 1]\n\n\nThe init_delay is valid only when init_delay_sd is set.\n\n\n\n\n\n\ninitial_delay\n\n\n[3, 0]\n\n\n4\n\n\n[0, 15]\n\n\nConfigures the initial delay\n\n\n\n\n\n\n\n\n0010 - REFI2\n\u00b6\n\n\n26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  0  1  0  A  B  B  B  B  B  B  C  D  E  E  E  E  F  G  G  G  G  G  H  H  H  H\n\n\n\n\n\n\n\n\n\n\nField\n\n\nPosition\n\n\nWidth\n\n\nRange/Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninstr_code\n\n\n[26, 23]\n\n\n4\n\n\nb'0010\n\n\nREFI2 instruction code\n\n\n\n\n\n\nstep_val_sd\n\n\n22\n\n\n1\n\n\n[0, 1]\n\n\nThe step_val is valid only if step_val_sd is set.\n\n\n\n\n\n\nstep_val\n\n\n[21, 16]\n\n\n6\n\n\n[0, 63]\n\n\nStep incremental/decremental value of the address\n\n\n\n\n\n\nstep_val_sign\n\n\n15\n\n\n1\n\n\n[0, 1]\n\n\nIf it's 0, address will be incremented by the step_val else decremented by the step_val\n\n\n\n\n\n\nrefi_middle_delay_sd\n\n\n14\n\n\n1\n\n\n[0, 63]\n\n\nThe refi_middle_delay is valid only if refi_middle_delay_sd is 0\n\n\n\n\n\n\nrefi_middle_delay\n\n\n[13, 10]\n\n\n4\n\n\n[0, 15]\n\n\nConfigures the middle dealy\n\n\n\n\n\n\nno_of_reps_sd\n\n\n9\n\n\n1\n\n\n[0, 1]\n\n\nThe no_of_reps is valid only when the no_of_reps_sd is 0, otherwise the no_of_reps value would be taken from the RACCU register\n\n\n\n\n\n\nno_of_reps\n\n\n[8, 4]\n\n\n5\n\n\n[0, 31]\n\n\nConfigures the number of times the address pattern to repeat\n\n\n\n\n\n\nrpt_step_value\n\n\n[3, 0]\n\n\n4\n\n\n[0, 15]\n\n\nThe step increment/decrement value\n\n\n\n\n\n\n\n\n0011 - REFI3\n\u00b6\n\n\n0100 - DPU\n\u00b6\n\n\n26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  0  0  A  A  A  A  A  B  B  C  C  D  D  E  F  G  G  G  G  G  G  G  G  H  H\n\n\n\n\n\n\n\n\n\n\nField\n\n\nPosition\n\n\nWidth\n\n\nRange/Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninstr_code\n\n\n[26, 23]\n\n\n4\n\n\nb'0100\n\n\nDPU instruction code\n\n\n\n\n\n\ndpu_mode\n\n\n[22, 18]\n\n\n5\n\n\n[0, 12]\n\n\nConfigures the valid dpu mode\n\n\n\n\n\n\ndpu_saturation\n\n\n[17, 16]\n\n\n2\n\n\n[0, 3]\n\n\nSelects the integer or fixed point operation with or without saturation \n1\n\n\n\n\n\n\ndpu_output_a\n\n\n[15, 14]\n\n\n2\n\n\n[0, 3]\n\n\nSelects one or both the outports \n2\n\n\n\n\n\n\ndpu_output_b\n\n\n[13, 12]\n\n\n2\n\n\n[0, 3]\n\n\nSelects one or both the outports \n2\n\n\n\n\n\n\ndpu_acc_clear_rst\n\n\n11\n\n\n1\n\n\n[0, 1]\n\n\nAsynchronous reset, when set, clears the DPU accumulator register.\n\n\n\n\n\n\ndpu_acc_clear_sd\n\n\n10\n\n\n1\n\n\n[0, 1]\n\n\nThe dpu_acc_clear is valid only when dpu acc_clear_sd is set.\n\n\n\n\n\n\ndpu_acc_clear\n\n\n[9, 2]\n\n\n8\n\n\n[0, 255]\n\n\nThe DPU accumulator register is cleared when the accumulator counter reaches the value configured in the dpu_acc_clear\n\n\n\n\n\n\ndpu_process_inout\n\n\n[1, 0]\n\n\n2\n\n\n[0, 3]\n\n\nProcesses the input or output \n3\n\n\n\n\n\n\n\n\n0101 - SWB\n\u00b6\n\n\n\n\nInfo\n\n\nThe actual 27-bit machine code is automatically calculated by the fabric while doing simulation or by the compiler.\n\n\n\n\n\n\n\n\n\n\nField\n\n\nPosition\n\n\nWidth\n\n\nRange/Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninstr_code\n\n\nN/A\n\n\nN/A\n\n\nb'0101\n\n\nSWB instruction code\n\n\n\n\n\n\nfrom_block\n\n\nN/A\n\n\nN/A\n\n\nN/A\n\n\nThe source block\n4\n\n\n\n\n\n\nfrom_address\n\n\nN/A\n\n\nN/A\n\n\nN/A\n\n\nThe source unit address\n5\n\n\n\n\n\n\nfrom_port\n\n\nN/A\n\n\nN/A\n\n\nN/A\n\n\nThe source port\n\n\n\n\n\n\nto_block\n\n\nN/A\n\n\nN/A\n\n\nN/A\n\n\nThe destination block\n4\n\n\n\n\n\n\nto_address\n\n\nN/A\n\n\nN/A\n\n\nN/A\n\n\nThe destination unit address\n5\n\n\n\n\n\n\nto_port\n\n\nN/A\n\n\nN/A\n\n\nN/A\n\n\nThe destination port\n\n\n\n\n\n\n\n\n0110 - JUMP\n\u00b6\n\n\n26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  0  A  A  A  A  A  A  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\n\n\n\n\n\n\n\n\n\nField\n\n\nPosition\n\n\nWidth\n\n\nRange/Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninstr_code\n\n\n[26, 23]\n\n\n4\n\n\nb'0110\n\n\nJUMP instruction code\n\n\n\n\n\n\ntrue_addrs\n\n\n[22, 17]\n\n\n6\n6\n\n\n[0, 63]\n\n\nThe target address\n\n\n\n\n\n\nN/A\n\n\n[16, 0]\n\n\n17\n\n\nN/A\n\n\nN/A\n\n\n\n\n\n\n\n\n0111 - DELAY\n\u00b6\n\n\n26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  1  A  B  B  B  B  B  B  B  B  B  B  B  B  B  B  B  -  -  -  -  -  -  -\n\n\n\n\n\n\n\n\n\n\nField\n\n\nPosition\n\n\nWidth\n\n\nRange/Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninstr_code\n\n\n[26, 23]\n\n\n4\n\n\nb'0111\n\n\nDELAY instruction code\n\n\n\n\n\n\ndel_cycles_sd\n\n\n22\n\n\n1\n\n\n[0, 1]\n\n\nThe del_cycles is valid only if del_cycles_sd is set\n\n\n\n\n\n\ndel_cycles\n\n\n[21, 7]\n\n\n15\n\n\n[0, 32767]\n\n\nNumber of clock cycles to wait before decoding the next instruction\n\n\n\n\n\n\nN/A\n\n\n[6, 0]\n\n\n7\n\n\nN/A\n\n\nN/A\n\n\n\n\n\n\n\n\n1000 - FOR_HEADER\n\u00b6\n\n\n1001 - FOR_TAIL\n\u00b6\n\n\n1010 - RACCU\n\u00b6\n\n\n1011 - BRANCH\n\u00b6\n\n\n26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  1  A  A  B  B  B  B  B  B  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\n\n\n\n\n\n\n\n\n\nField\n\n\nPosition\n\n\nWidth\n\n\nRange/Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninstr_code\n\n\n[26, 23]\n\n\n4\n\n\nb'1011\n\n\nBRANCH instruction code\n\n\n\n\n\n\nbrnch_mode\n\n\n[22, 21]\n\n\n2\n\n\n[0, 4]\n\n\nThe conditional branch jumps to the false address when the (brnch_mode && seq_cond_status) == \"00\"\n\n\n\n\n\n\nbrnch_false_addr\n\n\n[20, 15]\n\n\n6\n6\n\n\n[0, 63]\n\n\nConfigures the false address\n\n\n\n\n\n\nN/A\n\n\n[14, 0]\n\n\n15\n\n\nN/A\n\n\nN/A\n\n\n\n\n\n\n\n\n1100 - ROUTE\n\u00b6\n\n\n1101 - SRAM_READ\n\u00b6\n\n\n1110 - SRAM_WRITE\n\u00b6\n\n\n1111 - HALT\n7\n\u00b6\n\n\n26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n1  1  1  1  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -\n\n\n\n\n\n\n\n\n\n\nField\n\n\nPosition\n\n\nWidth\n\n\nRange/Value\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ninstr_code\n\n\n[26, 23]\n\n\n4\n\n\nb'1111\n\n\nHALT instruction code\n\n\n\n\n\n\nN/A\n\n\n[22, 0]\n\n\n23\n\n\nN/A\n\n\nN/A\n\n\n\n\n\n\n\n\nExample\n\u00b6\n\n\nMatlab code\n\u00b6\n\n\nA\n \n=\n \n[\n3\n \n:\n \n12\n];\n \n%! RFILE<> [0,0]\n\n\nB\n \n=\n \n[\n5\n \n:\n \n14\n];\n \n%! RFILE<> [0,0]\n\n\nC\n \n=\n \n[\n0\n];\n      \n%! RFILE<> [0,0]\n\n\n\nC\n(\n1\n)\n \n=\n \nA\n(\n1\n)\n \n+\n \nB\n(\n1\n);\n \n%! DPU [0,0]\n\n\n\n\n\nManus assembly code\n\u00b6\n\n\n.DATA\n$A FULL_DISTR [<0,0>] [3,4,5,6,7,8,9,10,11,12]\n$B FULL_DISTR [<0,0>] [5,6,7,8,9,10,11,12,13,14]\n$C FULL_DISTR [<0,0>] [0]\n\n.CODE\nCELL    <0,0>\nSWB     0  0  3  1  0  2\nSWB     0  0  2  1  0  3\nSWB     1  0  0  0  0  1\nREFI1   3  0  0  0  0  0  0  2\nREFI1   2  0  0  10 0  0  0  1\nDPU     10 0  3  3  1  0  0  0\nREFI1   1  0  0  20 0  0  0  0\n\n\n\n\nLimitations\n\u00b6\n\n\n\n\nDoesn't support fixed-point representation, you need to convert fixed-point to integer format manually.\n\n\nDoesn't support DiMarch variable declaration.\n\n\nDoesn't support Input and Output variable type, only Temporary variable type is valid.\n\n\nNo static time model analysis. The execution cycle is by default set to 1000.\n\n\n\n\n\n\n\n\n\n\n\n\nSaturation\n:\n[0]: Integer operation without saturation;\n[1]: Fixed point without saturation;\n[2]: Integer operation with saturation;\n[3]: Fixed point with saturation;\u00a0\n\u21a9\n\n\n\n\n\n\nOutput ports\n:\n[0]: Disables both out ports;\n[1]: Out port 0 will be enabled;\n[2]: Out port 1 will be enabled;\n[3]: Both Out port 0 and 1 will be enabled;\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nProcess ports\n:\n[0]: No preprocessing;\n[1]: Negates input 0;\n[2]: Negates input 1;\n[3]: Absolute of (in0-in1);\u00a0\n\u21a9\n\n\n\n\n\n\nThis block refers to the alias of register file or datapath unit.\n[0] Register file\n[1] Datapath unit\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nThis address is calculated according to \n\\(addr=row+col*2\\)\n. Since in standard fabric,\nmaxtimum continued row is 2.\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nThis number equals to PC size, which is \n\\(log_2(DEPTH_{instr})\\)\n. By default, \n\\(DEPTH_{instr} = 64\\)\n.\u00a0\n\u21a9\n\u21a9\n\n\n\n\n\n\nThis instruction is not used.\u00a0\n\u21a9",
            "title": "Manus"
        },
        {
            "location": "/Compiler/Manus/#manus-code",
            "text": "",
            "title": "Manus code"
        },
        {
            "location": "/Compiler/Manus/#structure",
            "text": "Manus code is a kind of text-based assembly language for SiLago platform. Manus code is caseless.",
            "title": "Structure"
        },
        {
            "location": "/Compiler/Manus/#segment",
            "text": "Manus code consists of segments. Two type of segments are valid in Manus code. They are  DATA SEGMENT  and  CODE SEGMENT  which are marked by  .DATA  and  .CODE  respectively. All the contents following a segment mark belong to that specific segment.  DATA SEGMENT  is used for declare and initialize variables in register file, while  CODE SEGMENT  is used for assign instructions to  sequencer  of each DRRA cell.",
            "title": "Segment"
        },
        {
            "location": "/Compiler/Manus/#variable",
            "text": "Variables should be defined in  DATA SEGMENT . The defination format is:  $variable_name distribution_type [<row0, col0>, <row1, col1>, ...] [element0, element1, ...]  or  $variable_name distribution_type [<row0, col0>, <row1, col1>, ...] ZEROS(number_of_element)  or  $variable_name distribution_type [<row0, col0>, <row1, col1>, ...] ONES(number_of_element)  Variable name should always be led by a dollar ( $ ) symbol. The first symbol after dollar ( $ ) should only be underscore (  _  ) or regular latin letter (a-z, A-Z). The following symbol can be underscore (  _  ), regular latin letter (a-z, A-Z) as well as number (0-9).  Distribution type can be either  FULL_DISTR  or  EVEN_DIRSR .  The third argument is a list of DRRA cells.  The last argument is the list of initial value of each element inside the variable.  All variable are considered as a 1-D array in register file.",
            "title": "Variable"
        },
        {
            "location": "/Compiler/Manus/#drra-cell",
            "text": "To specify a DRRA cell for following instructions, use:  CELL <row, col>",
            "title": "DRRA cell"
        },
        {
            "location": "/Compiler/Manus/#instructions",
            "text": "Instructions should be defined in  CODE SEGMENT . The defination format is:  instruction_name arg0 arg1 ...  or  instruction_name arg0, arg1, ...  See next section for various instruction defination detail.",
            "title": "Instructions"
        },
        {
            "location": "/Compiler/Manus/#instructions-set",
            "text": "",
            "title": "Instructions set"
        },
        {
            "location": "/Compiler/Manus/#0001-refi1",
            "text": "26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  0  0  1  A  A  B  B  C  D  D  D  D  D  D  E  F  F  F  F  F  F  G  H  H  H  H     Field  Position  Width  Range/Value  Description      instr_code  [26, 23]  4  b'0001  REFI1 instruction code    reg_file_port  [22, 21]  2  [0, 3]  Selects one of the RFile ports    subseq_instrs  [20, 19]  2  [0, 3]  The instruction decoder fetches the consequent (REFI1) or (REFI1 and REFI2) instructions.    start_addrs_sd  18  1  [0, 1]  The start_addrs is valid only if the start_addrs_sd is 0. Otherwise the start_address would be taken from the RACCU register    start_addrs  [17, 12]  6  [0, 63]  Configures the starting address for the AGU    no_of_addrs_sd  11  1  [0, 1]  The no_of_addrs is valid only when no_of_addrs_sd is 0, otherwise the no_of_addrs would be taken from the RACCU register.    no_of_addrs  [10, 5]  6  [0, 63]  Configures the number of address for the AGU    initial_delay_sd:  4  1  [0, 1]  The init_delay is valid only when init_delay_sd is set.    initial_delay  [3, 0]  4  [0, 15]  Configures the initial delay",
            "title": "0001 - REFI1"
        },
        {
            "location": "/Compiler/Manus/#0010-refi2",
            "text": "26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  0  1  0  A  B  B  B  B  B  B  C  D  E  E  E  E  F  G  G  G  G  G  H  H  H  H     Field  Position  Width  Range/Value  Description      instr_code  [26, 23]  4  b'0010  REFI2 instruction code    step_val_sd  22  1  [0, 1]  The step_val is valid only if step_val_sd is set.    step_val  [21, 16]  6  [0, 63]  Step incremental/decremental value of the address    step_val_sign  15  1  [0, 1]  If it's 0, address will be incremented by the step_val else decremented by the step_val    refi_middle_delay_sd  14  1  [0, 63]  The refi_middle_delay is valid only if refi_middle_delay_sd is 0    refi_middle_delay  [13, 10]  4  [0, 15]  Configures the middle dealy    no_of_reps_sd  9  1  [0, 1]  The no_of_reps is valid only when the no_of_reps_sd is 0, otherwise the no_of_reps value would be taken from the RACCU register    no_of_reps  [8, 4]  5  [0, 31]  Configures the number of times the address pattern to repeat    rpt_step_value  [3, 0]  4  [0, 15]  The step increment/decrement value",
            "title": "0010 - REFI2"
        },
        {
            "location": "/Compiler/Manus/#0011-refi3",
            "text": "",
            "title": "0011 - REFI3"
        },
        {
            "location": "/Compiler/Manus/#0100-dpu",
            "text": "26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  0  0  A  A  A  A  A  B  B  C  C  D  D  E  F  G  G  G  G  G  G  G  G  H  H     Field  Position  Width  Range/Value  Description      instr_code  [26, 23]  4  b'0100  DPU instruction code    dpu_mode  [22, 18]  5  [0, 12]  Configures the valid dpu mode    dpu_saturation  [17, 16]  2  [0, 3]  Selects the integer or fixed point operation with or without saturation  1    dpu_output_a  [15, 14]  2  [0, 3]  Selects one or both the outports  2    dpu_output_b  [13, 12]  2  [0, 3]  Selects one or both the outports  2    dpu_acc_clear_rst  11  1  [0, 1]  Asynchronous reset, when set, clears the DPU accumulator register.    dpu_acc_clear_sd  10  1  [0, 1]  The dpu_acc_clear is valid only when dpu acc_clear_sd is set.    dpu_acc_clear  [9, 2]  8  [0, 255]  The DPU accumulator register is cleared when the accumulator counter reaches the value configured in the dpu_acc_clear    dpu_process_inout  [1, 0]  2  [0, 3]  Processes the input or output  3",
            "title": "0100 - DPU"
        },
        {
            "location": "/Compiler/Manus/#0101-swb",
            "text": "Info  The actual 27-bit machine code is automatically calculated by the fabric while doing simulation or by the compiler.      Field  Position  Width  Range/Value  Description      instr_code  N/A  N/A  b'0101  SWB instruction code    from_block  N/A  N/A  N/A  The source block 4    from_address  N/A  N/A  N/A  The source unit address 5    from_port  N/A  N/A  N/A  The source port    to_block  N/A  N/A  N/A  The destination block 4    to_address  N/A  N/A  N/A  The destination unit address 5    to_port  N/A  N/A  N/A  The destination port",
            "title": "0101 - SWB"
        },
        {
            "location": "/Compiler/Manus/#0110-jump",
            "text": "26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  0  A  A  A  A  A  A  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -     Field  Position  Width  Range/Value  Description      instr_code  [26, 23]  4  b'0110  JUMP instruction code    true_addrs  [22, 17]  6 6  [0, 63]  The target address    N/A  [16, 0]  17  N/A  N/A",
            "title": "0110 - JUMP"
        },
        {
            "location": "/Compiler/Manus/#0111-delay",
            "text": "26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  1  A  B  B  B  B  B  B  B  B  B  B  B  B  B  B  B  -  -  -  -  -  -  -     Field  Position  Width  Range/Value  Description      instr_code  [26, 23]  4  b'0111  DELAY instruction code    del_cycles_sd  22  1  [0, 1]  The del_cycles is valid only if del_cycles_sd is set    del_cycles  [21, 7]  15  [0, 32767]  Number of clock cycles to wait before decoding the next instruction    N/A  [6, 0]  7  N/A  N/A",
            "title": "0111 - DELAY"
        },
        {
            "location": "/Compiler/Manus/#1000-for_header",
            "text": "",
            "title": "1000 - FOR_HEADER"
        },
        {
            "location": "/Compiler/Manus/#1001-for_tail",
            "text": "",
            "title": "1001 - FOR_TAIL"
        },
        {
            "location": "/Compiler/Manus/#1010-raccu",
            "text": "",
            "title": "1010 - RACCU"
        },
        {
            "location": "/Compiler/Manus/#1011-branch",
            "text": "26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n0  1  1  1  A  A  B  B  B  B  B  B  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -     Field  Position  Width  Range/Value  Description      instr_code  [26, 23]  4  b'1011  BRANCH instruction code    brnch_mode  [22, 21]  2  [0, 4]  The conditional branch jumps to the false address when the (brnch_mode && seq_cond_status) == \"00\"    brnch_false_addr  [20, 15]  6 6  [0, 63]  Configures the false address    N/A  [14, 0]  15  N/A  N/A",
            "title": "1011 - BRANCH"
        },
        {
            "location": "/Compiler/Manus/#1100-route",
            "text": "",
            "title": "1100 - ROUTE"
        },
        {
            "location": "/Compiler/Manus/#1101-sram_read",
            "text": "",
            "title": "1101 - SRAM_READ"
        },
        {
            "location": "/Compiler/Manus/#1110-sram_write",
            "text": "",
            "title": "1110 - SRAM_WRITE"
        },
        {
            "location": "/Compiler/Manus/#1111-halt7",
            "text": "26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00\n|  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |\n1  1  1  1  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -     Field  Position  Width  Range/Value  Description      instr_code  [26, 23]  4  b'1111  HALT instruction code    N/A  [22, 0]  23  N/A  N/A",
            "title": "1111 - HALT7"
        },
        {
            "location": "/Compiler/Manus/#example",
            "text": "",
            "title": "Example"
        },
        {
            "location": "/Compiler/Manus/#matlab-code",
            "text": "A   =   [ 3   :   12 ];   %! RFILE<> [0,0]  B   =   [ 5   :   14 ];   %! RFILE<> [0,0]  C   =   [ 0 ];        %! RFILE<> [0,0]  C ( 1 )   =   A ( 1 )   +   B ( 1 );   %! DPU [0,0]",
            "title": "Matlab code"
        },
        {
            "location": "/Compiler/Manus/#manus-assembly-code",
            "text": ".DATA\n$A FULL_DISTR [<0,0>] [3,4,5,6,7,8,9,10,11,12]\n$B FULL_DISTR [<0,0>] [5,6,7,8,9,10,11,12,13,14]\n$C FULL_DISTR [<0,0>] [0]\n\n.CODE\nCELL    <0,0>\nSWB     0  0  3  1  0  2\nSWB     0  0  2  1  0  3\nSWB     1  0  0  0  0  1\nREFI1   3  0  0  0  0  0  0  2\nREFI1   2  0  0  10 0  0  0  1\nDPU     10 0  3  3  1  0  0  0\nREFI1   1  0  0  20 0  0  0  0",
            "title": "Manus assembly code"
        },
        {
            "location": "/Compiler/Manus/#limitations",
            "text": "Doesn't support fixed-point representation, you need to convert fixed-point to integer format manually.  Doesn't support DiMarch variable declaration.  Doesn't support Input and Output variable type, only Temporary variable type is valid.  No static time model analysis. The execution cycle is by default set to 1000.       Saturation :\n[0]: Integer operation without saturation;\n[1]: Fixed point without saturation;\n[2]: Integer operation with saturation;\n[3]: Fixed point with saturation;\u00a0 \u21a9    Output ports :\n[0]: Disables both out ports;\n[1]: Out port 0 will be enabled;\n[2]: Out port 1 will be enabled;\n[3]: Both Out port 0 and 1 will be enabled;\u00a0 \u21a9 \u21a9    Process ports :\n[0]: No preprocessing;\n[1]: Negates input 0;\n[2]: Negates input 1;\n[3]: Absolute of (in0-in1);\u00a0 \u21a9    This block refers to the alias of register file or datapath unit.\n[0] Register file\n[1] Datapath unit\u00a0 \u21a9 \u21a9    This address is calculated according to  \\(addr=row+col*2\\) . Since in standard fabric,\nmaxtimum continued row is 2.\u00a0 \u21a9 \u21a9    This number equals to PC size, which is  \\(log_2(DEPTH_{instr})\\) . By default,  \\(DEPTH_{instr} = 64\\) .\u00a0 \u21a9 \u21a9    This instruction is not used.\u00a0 \u21a9",
            "title": "Limitations"
        },
        {
            "location": "/Compiler/Vesyla-Tutorial/",
            "text": "Vesyla tutorial\n\u00b6\n\n\nWorking environment\n\u00b6\n\n\n\n\nOS\n: Windows\n\n\nSoftware\n:\n\n\nMatlab\n\n\nQuestaSim\n\n\n\n\n\n\n\n\nWrite the matlab code\n\u00b6\n\n\nPlease Check full documentation of Vesyla (chapter 3) : \nVesyla user manual\n\n\nCompilation and simulation\n\u00b6\n\n\nFile structure\n\u00b6\n\n\n\n\nCompilation\n\u00b6\n\n\n\n\nCopy your matlab script into folder \n$AlgoSilDir/test/testcases/\n.\n\n\nEdit \n$AlgoSilDir/make/make_test.bat\n and change the \nfilename\n section as following.\n\nset\n file_name \n=\n \n^\n\n        \n<\nYOUR\n SCRIPT FILENAME WITHOUT SUFFIX\n>\n\n\n\n\nOpen \npowershell\n, change to \n$AlgoSilDir/make/\n directory and execute the \nmake_test.bat\n script.\n\ncd\n \n$AlgoSilDir\n\\\nmake\n\n.\n\\\nmake_test.exe\n\n\n\nWait for compilation and simulation. The simulation result (\npass\n or \nfail\n) will be reported at the end of the process.\n\n\nThe report can be found in folder \n$AlgoSilDir/test/testcases/\n.\n\n\n\n\nOutput files\n\u00b6\n\n\nPlease Check full documentation of Vesyla (section 4.3): \nVesyla user manual",
            "title": "Vesyla Tutorial"
        },
        {
            "location": "/Compiler/Vesyla-Tutorial/#vesyla-tutorial",
            "text": "",
            "title": "Vesyla tutorial"
        },
        {
            "location": "/Compiler/Vesyla-Tutorial/#working-environment",
            "text": "OS : Windows  Software :  Matlab  QuestaSim",
            "title": "Working environment"
        },
        {
            "location": "/Compiler/Vesyla-Tutorial/#write-the-matlab-code",
            "text": "Please Check full documentation of Vesyla (chapter 3) :  Vesyla user manual",
            "title": "Write the matlab code"
        },
        {
            "location": "/Compiler/Vesyla-Tutorial/#compilation-and-simulation",
            "text": "",
            "title": "Compilation and simulation"
        },
        {
            "location": "/Compiler/Vesyla-Tutorial/#file-structure",
            "text": "",
            "title": "File structure"
        },
        {
            "location": "/Compiler/Vesyla-Tutorial/#compilation",
            "text": "Copy your matlab script into folder  $AlgoSilDir/test/testcases/ .  Edit  $AlgoSilDir/make/make_test.bat  and change the  filename  section as following. set  file_name  =   ^ \n         < YOUR  SCRIPT FILENAME WITHOUT SUFFIX >   Open  powershell , change to  $AlgoSilDir/make/  directory and execute the  make_test.bat  script. cd   $AlgoSilDir \\ make . \\ make_test.exe  Wait for compilation and simulation. The simulation result ( pass  or  fail ) will be reported at the end of the process.  The report can be found in folder  $AlgoSilDir/test/testcases/ .",
            "title": "Compilation"
        },
        {
            "location": "/Compiler/Vesyla-Tutorial/#output-files",
            "text": "Please Check full documentation of Vesyla (section 4.3):  Vesyla user manual",
            "title": "Output files"
        },
        {
            "location": "/Compiler/Sylva/",
            "text": "Sylva\n\u00b6\n\n\nNew version of Sylva documentation: \nSylva documentation",
            "title": "Sylva"
        },
        {
            "location": "/Compiler/Sylva/#sylva",
            "text": "New version of Sylva documentation:  Sylva documentation",
            "title": "Sylva"
        },
        {
            "location": "/Library/",
            "text": "Warning\n\n\nDocumentation is not complete!",
            "title": "Library"
        },
        {
            "location": "/Application/Overview/",
            "text": "Warning\n\n\nDocumentation is not complete!",
            "title": "Overview"
        },
        {
            "location": "/Application/SiLagoDSP/Fast-Fourier-Projection/",
            "text": "Warning\n\n\nDocumentation is not complete!",
            "title": "Fast Fourier Projection"
        },
        {
            "location": "/About/",
            "text": "Warning\n\n\nDocumentation is not complete!",
            "title": "About"
        }
    ]
}