{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to SiLago Documentation Abstract This website hosts the all the documentation of SiLago project. Repos Fabric Repo Vesyla Repo Tool Chain Vesyla tutorial Vesyla programming guide","title":"Home"},{"location":"#welcome-to-silago-documentation","text":"Abstract This website hosts the all the documentation of SiLago project.","title":"Welcome to SiLago Documentation"},{"location":"#repos","text":"Fabric Repo Vesyla Repo","title":"Repos"},{"location":"#tool-chain","text":"Vesyla tutorial Vesyla programming guide","title":"Tool Chain"},{"location":"About/About/","text":"About Contributors Yu Yang : yuyang2@kth.se Dimitrios Stathis : stathis@kth.se","title":"About"},{"location":"About/About/#about","text":"","title":"About"},{"location":"About/About/#contributors","text":"Yu Yang : yuyang2@kth.se Dimitrios Stathis : stathis@kth.se","title":"Contributors"},{"location":"About/License/","text":"License This documentation is licensed under GNU Free Documentation License . A full legal document is listed below. You can also check the license contents from the official website: https://www.gnu.org/licenses/fdl.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 GNU Free Documentation License Version 1 . 3 , 3 November 2008 Copyright ( C ) 2000 , 2001 , 2002 , 2007 , 2008 Free Software Foundation , Inc . < https : // fsf . org /> Everyone is permitted to copy and distribute verbatim copies of this license document , but changing it is not allowed . 0 . PREAMBLE The purpose of this License is to make a manual , textbook , or other functional and useful document \"free\" in the sense of freedom : to assure everyone the effective freedom to copy and redistribute it , with or without modifying it , either commercially or noncommercially . Secondarily , this License preserves for the author and publisher a way to get credit for their work , while not being considered responsible for modifications made by others . This License is a kind of \"copyleft\" , which means that derivative works of the document must themselves be free in the same sense . It complements the GNU General Public License , which is a copyleft license designed for free software . We have designed this License in order to use it for manuals for free software , because free software needs free documentation : a free program should come with manuals providing the same freedoms that the software does . But this License is not limited to software manuals ; it can be used for any textual work , regardless of subject matter or whether it is published as a printed book . We recommend this License principally for works whose purpose is instruction or reference . 1 . APPLICABILITY AND DEFINITIONS This License applies to any manual or other work , in any medium , that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License . Such a notice grants a world - wide , royalty - free license , unlimited in duration , to use that work under the conditions stated herein . The \"Document\" , below , refers to any such manual or work . Any member of the public is a licensee , and is addressed as \"you\" . You accept the license if you copy , modify or distribute the work in a way requiring permission under copyright law . A \"Modified Version\" of the Document means any work containing the Document or a portion of it , either copied verbatim , or with modifications and / or translated into another language . A \"Secondary Section\" is a named appendix or a front - matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document 's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The \"Invariant Sections\" are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The \"Cover Texts\" are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A \"Transparent\" copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not \"Transparent\" is called \"Opaque\". Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only. The \"Title Page\" means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, \"Title Page\" means the text near the most prominent appearance of the work' s title , preceding the beginning of the body of the text . The \"publisher\" means any person or entity that distributes copies of the Document to the public . A section \"Entitled XYZ\" means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language . ( Here XYZ stands for a specific section name mentioned below , such as \"Acknowledgements\" , \"Dedications\" , \"Endorsements\" , or \"History\" .) To \"Preserve the Title\" of such a section when you modify the Document means that it remains a section \"Entitled XYZ\" according to this definition . The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document . These Warranty Disclaimers are considered to be included by reference in this License , but only as regards disclaiming warranties : any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License . 2 . VERBATIM COPYING You may copy and distribute the Document in any medium , either commercially or noncommercially , provided that this License , the copyright notices , and the license notice saying this License applies to the Document are reproduced in all copies , and that you add no other conditions whatsoever to those of this License . You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute . However , you may accept compensation in exchange for copies . If you distribute a large enough number of copies you must also follow the conditions in section 3 . You may also lend copies , under the same conditions stated above , and you may publicly display copies . 3 . COPYING IN QUANTITY If you publish printed copies ( or copies in media that commonly have printed covers ) of the Document , numbering more than 100 , and the Document 's license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document. 4. MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version: A. Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission. B. List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement. C. State on the Title page the name of the publisher of the Modified Version, as the publisher. D. Preserve all the copyright notices of the Document. E. Add an appropriate copyright notice for your modifications adjacent to the other copyright notices. F. Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below. G. Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document' s license notice . H . Include an unaltered copy of this License . I . Preserve the section Entitled \"History\" , Preserve its Title , and add to it an item stating at least the title , year , new authors , and publisher of the Modified Version as given on the Title Page . If there is no section Entitled \"History\" in the Document , create one stating the title , year , authors , and publisher of the Document as given on its Title Page , then add an item describing the Modified Version as stated in the previous sentence . J . Preserve the network location , if any , given in the Document for public access to a Transparent copy of the Document , and likewise the network locations given in the Document for previous versions it was based on . These may be placed in the \"History\" section . You may omit a network location for a work that was published at least four years before the Document itself , or if the original publisher of the version it refers to gives permission . K . For any section Entitled \"Acknowledgements\" or \"Dedications\" , Preserve the Title of the section , and preserve in the section all the substance and tone of each of the contributor acknowledgements and / or dedications given therein . L . Preserve all the Invariant Sections of the Document , unaltered in their text and in their titles . Section numbers or the equivalent are not considered part of the section titles . M . Delete any section Entitled \"Endorsements\" . Such a section may not be included in the Modified Version . N . Do not retitle any existing section to be Entitled \"Endorsements\" or to conflict in title with any Invariant Section . O . Preserve any Warranty Disclaimers . If the Modified Version includes new front - matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document , you may at your option designate some or all of these sections as invariant . To do this , add their titles to the list of Invariant Sections in the Modified Version 's license notice. These titles must be distinct from any other section titles. You may add a section Entitled \"Endorsements\", provided it contains nothing but endorsements of your Modified Version by various parties--for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version. 5. COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled \"History\" in the various original documents, forming one section Entitled \"History\"; likewise combine any sections Entitled \"Acknowledgements\", and any sections Entitled \"Dedications\". You must delete all sections Entitled \"Endorsements\". 6. COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document. 7. AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the copyright resulting from the compilation is not used to limit the legal rights of the compilation' s users beyond what the individual works permit . When the Document is included in an aggregate , this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document . If the Cover Text requirement of section 3 is applicable to these copies of the Document , then if the Document is less than one half of the entire aggregate , the Document 's Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate. 8. TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled \"Acknowledgements\", \"Dedications\", or \"History\", the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title. 9. TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it. 10. FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/licenses/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy' s public statement of acceptance of a version permanently authorizes you to choose that version for the Document . 11 . RELICENSING \"Massive Multiauthor Collaboration Site\" ( or \"MMC Site\" ) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works . A public wiki that anybody can edit is an example of such a server . A \"Massive Multiauthor Collaboration\" ( or \"MMC\" ) contained in the site means any set of copyrightable works thus published on the MMC site . \"CC-BY-SA\" means the Creative Commons Attribution - Share Alike 3 . 0 license published by Creative Commons Corporation , a not - for - profit corporation with a principal place of business in San Francisco , California , as well as future copyleft versions of that license published by that same organization . \"Incorporate\" means to publish or republish a Document , in whole or in part , as part of another Document . An MMC is \"eligible for relicensing\" if it is licensed under this License , and if all works that were first published under this License somewhere other than this MMC , and subsequently incorporated in whole or in part into the MMC , ( 1 ) had no cover texts or invariant sections , and ( 2 ) were thus incorporated prior to November 1 , 2008 . The operator of an MMC Site may republish an MMC contained in the site under CC - BY - SA on the same site at any time before August 1 , 2009 , provided the MMC is eligible for relicensing . ADDENDUM : How to use this License for your documents To use this License in a document you have written , include a copy of the License in the document and put the following copyright and license notices just after the title page : Copyright ( c ) YEAR YOUR NAME . Permission is granted to copy , distribute and / or modify this document under the terms of the GNU Free Documentation License , Version 1 . 3 or any later version published by the Free Software Foundation ; with no Invariant Sections , no Front - Cover Texts , and no Back - Cover Texts . A copy of the license is included in the section entitled \"GNU Free Documentation License\" . If you have Invariant Sections , Front - Cover Texts and Back - Cover Texts , replace the \"with...Texts.\" line with this : with the Invariant Sections being LIST THEIR TITLES , with the Front - Cover Texts being LIST , and with the Back - Cover Texts being LIST . If you have Invariant Sections without Cover Texts , or some other combination of the three , merge those two alternatives to suit the situation . If your document contains nontrivial examples of program code , we recommend releasing these examples in parallel under your choice of free software license , such as the GNU General Public License , to permit their use in free software .","title":"License"},{"location":"About/License/#license","text":"This documentation is licensed under GNU Free Documentation License . A full legal document is listed below. You can also check the license contents from the official website: https://www.gnu.org/licenses/fdl.html 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 GNU Free Documentation License Version 1 . 3 , 3 November 2008 Copyright ( C ) 2000 , 2001 , 2002 , 2007 , 2008 Free Software Foundation , Inc . < https : // fsf . org /> Everyone is permitted to copy and distribute verbatim copies of this license document , but changing it is not allowed . 0 . PREAMBLE The purpose of this License is to make a manual , textbook , or other functional and useful document \"free\" in the sense of freedom : to assure everyone the effective freedom to copy and redistribute it , with or without modifying it , either commercially or noncommercially . Secondarily , this License preserves for the author and publisher a way to get credit for their work , while not being considered responsible for modifications made by others . This License is a kind of \"copyleft\" , which means that derivative works of the document must themselves be free in the same sense . It complements the GNU General Public License , which is a copyleft license designed for free software . We have designed this License in order to use it for manuals for free software , because free software needs free documentation : a free program should come with manuals providing the same freedoms that the software does . But this License is not limited to software manuals ; it can be used for any textual work , regardless of subject matter or whether it is published as a printed book . We recommend this License principally for works whose purpose is instruction or reference . 1 . APPLICABILITY AND DEFINITIONS This License applies to any manual or other work , in any medium , that contains a notice placed by the copyright holder saying it can be distributed under the terms of this License . Such a notice grants a world - wide , royalty - free license , unlimited in duration , to use that work under the conditions stated herein . The \"Document\" , below , refers to any such manual or work . Any member of the public is a licensee , and is addressed as \"you\" . You accept the license if you copy , modify or distribute the work in a way requiring permission under copyright law . A \"Modified Version\" of the Document means any work containing the Document or a portion of it , either copied verbatim , or with modifications and / or translated into another language . A \"Secondary Section\" is a named appendix or a front - matter section of the Document that deals exclusively with the relationship of the publishers or authors of the Document to the Document 's overall subject (or to related matters) and contains nothing that could fall directly within that overall subject. (Thus, if the Document is in part a textbook of mathematics, a Secondary Section may not explain any mathematics.) The relationship could be a matter of historical connection with the subject or with related matters, or of legal, commercial, philosophical, ethical or political position regarding them. The \"Invariant Sections\" are certain Secondary Sections whose titles are designated, as being those of Invariant Sections, in the notice that says that the Document is released under this License. If a section does not fit the above definition of Secondary then it is not allowed to be designated as Invariant. The Document may contain zero Invariant Sections. If the Document does not identify any Invariant Sections then there are none. The \"Cover Texts\" are certain short passages of text that are listed, as Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document is released under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at most 25 words. A \"Transparent\" copy of the Document means a machine-readable copy, represented in a format whose specification is available to the general public, that is suitable for revising the document straightforwardly with generic text editors or (for images composed of pixels) generic paint programs or (for drawings) some widely available drawing editor, and that is suitable for input to text formatters or for automatic translation to a variety of formats suitable for input to text formatters. A copy made in an otherwise Transparent file format whose markup, or absence of markup, has been arranged to thwart or discourage subsequent modification by readers is not Transparent. An image format is not Transparent if used for any substantial amount of text. A copy that is not \"Transparent\" is called \"Opaque\". Examples of suitable formats for Transparent copies include plain ASCII without markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly available DTD, and standard-conforming simple HTML, PostScript or PDF designed for human modification. Examples of transparent image formats include PNG, XCF and JPG. Opaque formats include proprietary formats that can be read and edited only by proprietary word processors, SGML or XML for which the DTD and/or processing tools are not generally available, and the machine-generated HTML, PostScript or PDF produced by some word processors for output purposes only. The \"Title Page\" means, for a printed book, the title page itself, plus such following pages as are needed to hold, legibly, the material this License requires to appear in the title page. For works in formats which do not have any title page as such, \"Title Page\" means the text near the most prominent appearance of the work' s title , preceding the beginning of the body of the text . The \"publisher\" means any person or entity that distributes copies of the Document to the public . A section \"Entitled XYZ\" means a named subunit of the Document whose title either is precisely XYZ or contains XYZ in parentheses following text that translates XYZ in another language . ( Here XYZ stands for a specific section name mentioned below , such as \"Acknowledgements\" , \"Dedications\" , \"Endorsements\" , or \"History\" .) To \"Preserve the Title\" of such a section when you modify the Document means that it remains a section \"Entitled XYZ\" according to this definition . The Document may include Warranty Disclaimers next to the notice which states that this License applies to the Document . These Warranty Disclaimers are considered to be included by reference in this License , but only as regards disclaiming warranties : any other implication that these Warranty Disclaimers may have is void and has no effect on the meaning of this License . 2 . VERBATIM COPYING You may copy and distribute the Document in any medium , either commercially or noncommercially , provided that this License , the copyright notices , and the license notice saying this License applies to the Document are reproduced in all copies , and that you add no other conditions whatsoever to those of this License . You may not use technical measures to obstruct or control the reading or further copying of the copies you make or distribute . However , you may accept compensation in exchange for copies . If you distribute a large enough number of copies you must also follow the conditions in section 3 . You may also lend copies , under the same conditions stated above , and you may publicly display copies . 3 . COPYING IN QUANTITY If you publish printed copies ( or copies in media that commonly have printed covers ) of the Document , numbering more than 100 , and the Document 's license notice requires Cover Texts, you must enclose the copies in covers that carry, clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on the back cover. Both covers must also clearly and legibly identify you as the publisher of these copies. The front cover must present the full title with all words of the title equally prominent and visible. You may add other material on the covers in addition. Copying with changes limited to the covers, as long as they preserve the title of the Document and satisfy these conditions, can be treated as verbatim copying in other respects. If the required texts for either cover are too voluminous to fit legibly, you should put the first ones listed (as many as fit reasonably) on the actual cover, and continue the rest onto adjacent pages. If you publish or distribute Opaque copies of the Document numbering more than 100, you must either include a machine-readable Transparent copy along with each Opaque copy, or state in or with each Opaque copy a computer-network location from which the general network-using public has access to download using public-standard network protocols a complete Transparent copy of the Document, free of added material. If you use the latter option, you must take reasonably prudent steps, when you begin distribution of Opaque copies in quantity, to ensure that this Transparent copy will remain thus accessible at the stated location until at least one year after the last time you distribute an Opaque copy (directly or through your agents or retailers) of that edition to the public. It is requested, but not required, that you contact the authors of the Document well before redistributing any large number of copies, to give them a chance to provide you with an updated version of the Document. 4. MODIFICATIONS You may copy and distribute a Modified Version of the Document under the conditions of sections 2 and 3 above, provided that you release the Modified Version under precisely this License, with the Modified Version filling the role of the Document, thus licensing distribution and modification of the Modified Version to whoever possesses a copy of it. In addition, you must do these things in the Modified Version: A. Use in the Title Page (and on the covers, if any) a title distinct from that of the Document, and from those of previous versions (which should, if there were any, be listed in the History section of the Document). You may use the same title as a previous version if the original publisher of that version gives permission. B. List on the Title Page, as authors, one or more persons or entities responsible for authorship of the modifications in the Modified Version, together with at least five of the principal authors of the Document (all of its principal authors, if it has fewer than five), unless they release you from this requirement. C. State on the Title page the name of the publisher of the Modified Version, as the publisher. D. Preserve all the copyright notices of the Document. E. Add an appropriate copyright notice for your modifications adjacent to the other copyright notices. F. Include, immediately after the copyright notices, a license notice giving the public permission to use the Modified Version under the terms of this License, in the form shown in the Addendum below. G. Preserve in that license notice the full lists of Invariant Sections and required Cover Texts given in the Document' s license notice . H . Include an unaltered copy of this License . I . Preserve the section Entitled \"History\" , Preserve its Title , and add to it an item stating at least the title , year , new authors , and publisher of the Modified Version as given on the Title Page . If there is no section Entitled \"History\" in the Document , create one stating the title , year , authors , and publisher of the Document as given on its Title Page , then add an item describing the Modified Version as stated in the previous sentence . J . Preserve the network location , if any , given in the Document for public access to a Transparent copy of the Document , and likewise the network locations given in the Document for previous versions it was based on . These may be placed in the \"History\" section . You may omit a network location for a work that was published at least four years before the Document itself , or if the original publisher of the version it refers to gives permission . K . For any section Entitled \"Acknowledgements\" or \"Dedications\" , Preserve the Title of the section , and preserve in the section all the substance and tone of each of the contributor acknowledgements and / or dedications given therein . L . Preserve all the Invariant Sections of the Document , unaltered in their text and in their titles . Section numbers or the equivalent are not considered part of the section titles . M . Delete any section Entitled \"Endorsements\" . Such a section may not be included in the Modified Version . N . Do not retitle any existing section to be Entitled \"Endorsements\" or to conflict in title with any Invariant Section . O . Preserve any Warranty Disclaimers . If the Modified Version includes new front - matter sections or appendices that qualify as Secondary Sections and contain no material copied from the Document , you may at your option designate some or all of these sections as invariant . To do this , add their titles to the list of Invariant Sections in the Modified Version 's license notice. These titles must be distinct from any other section titles. You may add a section Entitled \"Endorsements\", provided it contains nothing but endorsements of your Modified Version by various parties--for example, statements of peer review or that the text has been approved by an organization as the authoritative definition of a standard. You may add a passage of up to five words as a Front-Cover Text, and a passage of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may be added by (or through arrangements made by) any one entity. If the Document already includes a cover text for the same cover, previously added by you or by arrangement made by the same entity you are acting on behalf of, you may not add another; but you may replace the old one, on explicit permission from the previous publisher that added the old one. The author(s) and publisher(s) of the Document do not by this License give permission to use their names for publicity for or to assert or imply endorsement of any Modified Version. 5. COMBINING DOCUMENTS You may combine the Document with other documents released under this License, under the terms defined in section 4 above for modified versions, provided that you include in the combination all of the Invariant Sections of all of the original documents, unmodified, and list them all as Invariant Sections of your combined work in its license notice, and that you preserve all their Warranty Disclaimers. The combined work need only contain one copy of this License, and multiple identical Invariant Sections may be replaced with a single copy. If there are multiple Invariant Sections with the same name but different contents, make the title of each such section unique by adding at the end of it, in parentheses, the name of the original author or publisher of that section if known, or else a unique number. Make the same adjustment to the section titles in the list of Invariant Sections in the license notice of the combined work. In the combination, you must combine any sections Entitled \"History\" in the various original documents, forming one section Entitled \"History\"; likewise combine any sections Entitled \"Acknowledgements\", and any sections Entitled \"Dedications\". You must delete all sections Entitled \"Endorsements\". 6. COLLECTIONS OF DOCUMENTS You may make a collection consisting of the Document and other documents released under this License, and replace the individual copies of this License in the various documents with a single copy that is included in the collection, provided that you follow the rules of this License for verbatim copying of each of the documents in all other respects. You may extract a single document from such a collection, and distribute it individually under this License, provided you insert a copy of this License into the extracted document, and follow this License in all other respects regarding verbatim copying of that document. 7. AGGREGATION WITH INDEPENDENT WORKS A compilation of the Document or its derivatives with other separate and independent documents or works, in or on a volume of a storage or distribution medium, is called an \"aggregate\" if the copyright resulting from the compilation is not used to limit the legal rights of the compilation' s users beyond what the individual works permit . When the Document is included in an aggregate , this License does not apply to the other works in the aggregate which are not themselves derivative works of the Document . If the Cover Text requirement of section 3 is applicable to these copies of the Document , then if the Document is less than one half of the entire aggregate , the Document 's Cover Texts may be placed on covers that bracket the Document within the aggregate, or the electronic equivalent of covers if the Document is in electronic form. Otherwise they must appear on printed covers that bracket the whole aggregate. 8. TRANSLATION Translation is considered a kind of modification, so you may distribute translations of the Document under the terms of section 4. Replacing Invariant Sections with translations requires special permission from their copyright holders, but you may include translations of some or all Invariant Sections in addition to the original versions of these Invariant Sections. You may include a translation of this License, and all the license notices in the Document, and any Warranty Disclaimers, provided that you also include the original English version of this License and the original versions of those notices and disclaimers. In case of a disagreement between the translation and the original version of this License or a notice or disclaimer, the original version will prevail. If a section in the Document is Entitled \"Acknowledgements\", \"Dedications\", or \"History\", the requirement (section 4) to Preserve its Title (section 1) will typically require changing the actual title. 9. TERMINATION You may not copy, modify, sublicense, or distribute the Document except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, or distribute it is void, and will automatically terminate your rights under this License. However, if you cease all violation of this License, then your license from a particular copyright holder is reinstated (a) provisionally, unless and until the copyright holder explicitly and finally terminates your license, and (b) permanently, if the copyright holder fails to notify you of the violation by some reasonable means prior to 60 days after the cessation. Moreover, your license from a particular copyright holder is reinstated permanently if the copyright holder notifies you of the violation by some reasonable means, this is the first time you have received notice of violation of this License (for any work) from that copyright holder, and you cure the violation prior to 30 days after your receipt of the notice. Termination of your rights under this section does not terminate the licenses of parties who have received copies or rights from you under this License. If your rights have been terminated and not permanently reinstated, receipt of a copy of some or all of the same material does not give you any rights to use it. 10. FUTURE REVISIONS OF THIS LICENSE The Free Software Foundation may publish new, revised versions of the GNU Free Documentation License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. See https://www.gnu.org/licenses/. Each version of the License is given a distinguishing version number. If the Document specifies that a particular numbered version of this License \"or any later version\" applies to it, you have the option of following the terms and conditions either of that specified version or of any later version that has been published (not as a draft) by the Free Software Foundation. If the Document does not specify a version number of this License, you may choose any version ever published (not as a draft) by the Free Software Foundation. If the Document specifies that a proxy can decide which future versions of this License can be used, that proxy' s public statement of acceptance of a version permanently authorizes you to choose that version for the Document . 11 . RELICENSING \"Massive Multiauthor Collaboration Site\" ( or \"MMC Site\" ) means any World Wide Web server that publishes copyrightable works and also provides prominent facilities for anybody to edit those works . A public wiki that anybody can edit is an example of such a server . A \"Massive Multiauthor Collaboration\" ( or \"MMC\" ) contained in the site means any set of copyrightable works thus published on the MMC site . \"CC-BY-SA\" means the Creative Commons Attribution - Share Alike 3 . 0 license published by Creative Commons Corporation , a not - for - profit corporation with a principal place of business in San Francisco , California , as well as future copyleft versions of that license published by that same organization . \"Incorporate\" means to publish or republish a Document , in whole or in part , as part of another Document . An MMC is \"eligible for relicensing\" if it is licensed under this License , and if all works that were first published under this License somewhere other than this MMC , and subsequently incorporated in whole or in part into the MMC , ( 1 ) had no cover texts or invariant sections , and ( 2 ) were thus incorporated prior to November 1 , 2008 . The operator of an MMC Site may republish an MMC contained in the site under CC - BY - SA on the same site at any time before August 1 , 2009 , provided the MMC is eligible for relicensing . ADDENDUM : How to use this License for your documents To use this License in a document you have written , include a copy of the License in the document and put the following copyright and license notices just after the title page : Copyright ( c ) YEAR YOUR NAME . Permission is granted to copy , distribute and / or modify this document under the terms of the GNU Free Documentation License , Version 1 . 3 or any later version published by the Free Software Foundation ; with no Invariant Sections , no Front - Cover Texts , and no Back - Cover Texts . A copy of the license is included in the section entitled \"GNU Free Documentation License\" . If you have Invariant Sections , Front - Cover Texts and Back - Cover Texts , replace the \"with...Texts.\" line with this : with the Invariant Sections being LIST THEIR TITLES , with the Front - Cover Texts being LIST , and with the Back - Cover Texts being LIST . If you have Invariant Sections without Cover Texts , or some other combination of the three , merge those two alternatives to suit the situation . If your document contains nontrivial examples of program code , we recommend releasing these examples in parallel under your choice of free software license , such as the GNU General Public License , to permit their use in free software .","title":"License"},{"location":"Docs/Application/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/Application/SiLagoDSP/Fast-Fourier-Projection/","text":"Warning Documentation is not complete!","title":"Fast Fourier Projection"},{"location":"Docs/Fabric/Overview/","text":"Overview Please check the specification of DRRA: DRRA Specification","title":"Overview"},{"location":"Docs/Fabric/Overview/#overview","text":"Please check the specification of DRRA: DRRA Specification","title":"Overview"},{"location":"Docs/Fabric/DRRA/RACCU/","text":"Run-time Address Constraint Computing Unit Function Run-time Address Constraint Computing Unit (RACCU) is used for computing address constraint for Address Generation Unit (AGU). AGU can deal with maximum 2-level affine address function. Affine address function is a function that can be expressed by equation below: \\begin{align} y = ax+b \\end{align} \\begin{align} y = ax+b \\end{align} where a and b are constraints. 2-level affine address function can then be expressed as: \\begin{align} y = c(ax+b)+d \\end{align} \\begin{align} y = c(ax+b)+d \\end{align} where a , b , c and d are constraints. Address constraint can be immediate value or a number generated at run-time according to a given function. The resources which deal with the constraint generation is the RACCU. Specification Info Old RACCU implementation. RACCU is a unit inside Sequencer. It has a register file of default depth N=8 . Contraints and temporary variables will be stored inside this register file. The data register is always exposed to Sequencer to read. Another register file in RACCU is used to manage the loops. The depth depends on maximum nested loop RACCU can handle, by default it's 4 . Each entry in loop management register file has 3 fields: Loop id Loop counter Loop end flag The loop id will be identify the entry location in the loop management register file. Loop counter will be initialized by the first LOOP_HEADER instruction and be changed periodically by LOOP_TAIL instruction. The comparison between the loop conter and loop bound is carried out by LOOP_HEADER instruction. If they are equal, loop end flag will be set to true and exits the loop. RACCU has a computation unit which is similar to a mini-DPU. It has 5 working modes. All of them are binary operations. They are: (0) RACCU_MODE_IDLE (1) RACCU_MODE_LOOP_H (2) RACCU_MODE_LOOP_T (3) RACCU_MODE_ADD (4) RACCU_MODE_SUB (5) RACCU_MODE_SHIFT_L (6) RACCU_MODE_SHIFT_R (7) RACCU_MODE_ADD_WITH_LOOP_INDEX Operands of each mode can be either immediate value from instruction or data from RACCU register whoes address is specified by the instruction. A bit is used to distinguish the operand origin. Info New RACCU implementation. RACCU is a unit inside Sequencer. It has a register file of default depth N=8 . Contraints, temporary variables and loop iterators will be stored inside this register file. The data register is always exposed to Sequencer to read. Loop iterator will be assigned from the beginning of the register file according to the order of loop while RACCU variables will be assigned from the end of register file. Once the loop iterators or the RACCU variables are not needed, they can be freed by moving the stack/heap pointer 1 position back. The assignment of register location is managed by the Vesyla compiler. RACCU has a computation unit which is similar to a mini-DPU. It has 8 working modes. All of them are binary operations. They are: (0) RACCU_MODE_IDLE (1) RACCU_MODE_LOOP_H (2) RACCU_MODE_LOOP_T (3) RACCU_MODE_ADD (4) RACCU_MODE_SUB (5) RACCU_MODE_SHIFT_L (6) RACCU_MODE_SHIFT_R (7) RACCU_MODE_LOG2 Operands of each mode can be either immediate value from instruction or data from RACCU register whoes address is specified by the instruction. A bit is used to distinguish the operand origin. Related Instructions RACCU instruction LOOP_HEADER instruction LOOP_TAIL instruction Info Old RACCU implementation. Signal I/O Type Description clk in std_logic Clock rst in std_logic Reset, active low op1_sd in std_logic Type of operand 1, 0-immediate, 1-reference op1 in std_logic_vector 8bits Operand 1 value / Operand 1 address op2_sd in std_logic Type of operand 2, 0-immediate, 1-reference op2 in std_logic_vector 8bits Operand 2 value / Operand 2 address cfg_mode in std_logic_vector 3bits Mode of RACCU computation unit result_addr in std_logic_vector 3bits Result address in data_reg data_reg out raccu_reg_out_ty Data register output loop_reg out raccu_loop_array_ty Loop register output Info New RACCU implementation. Signal I/O Type Description clk in std_logic Clock rst in std_logic Reset, active low op1_sd in std_logic Type of operand 1, 0-immediate, 1-reference op1 in std_logic_vector 8bits Operand 1 value / Operand 1 address op2_sd in std_logic Type of operand 2, 0-immediate, 1-reference op2 in std_logic_vector 8bits Operand 2 value / Operand 2 address cfg_mode in std_logic_vector 3bits Mode of RACCU computation unit result_addr in std_logic_vector 3bits Result address in data_reg data_reg out raccu_reg_out_ty Data register output","title":"Run-time Address Constraint Computing Unit"},{"location":"Docs/Fabric/DRRA/RACCU/#run-time-address-constraint-computing-unit","text":"","title":"Run-time Address Constraint Computing Unit"},{"location":"Docs/Fabric/DRRA/RACCU/#function","text":"Run-time Address Constraint Computing Unit (RACCU) is used for computing address constraint for Address Generation Unit (AGU). AGU can deal with maximum 2-level affine address function. Affine address function is a function that can be expressed by equation below: \\begin{align} y = ax+b \\end{align} \\begin{align} y = ax+b \\end{align} where a and b are constraints. 2-level affine address function can then be expressed as: \\begin{align} y = c(ax+b)+d \\end{align} \\begin{align} y = c(ax+b)+d \\end{align} where a , b , c and d are constraints. Address constraint can be immediate value or a number generated at run-time according to a given function. The resources which deal with the constraint generation is the RACCU.","title":"Function"},{"location":"Docs/Fabric/DRRA/RACCU/#specification","text":"Info Old RACCU implementation. RACCU is a unit inside Sequencer. It has a register file of default depth N=8 . Contraints and temporary variables will be stored inside this register file. The data register is always exposed to Sequencer to read. Another register file in RACCU is used to manage the loops. The depth depends on maximum nested loop RACCU can handle, by default it's 4 . Each entry in loop management register file has 3 fields: Loop id Loop counter Loop end flag The loop id will be identify the entry location in the loop management register file. Loop counter will be initialized by the first LOOP_HEADER instruction and be changed periodically by LOOP_TAIL instruction. The comparison between the loop conter and loop bound is carried out by LOOP_HEADER instruction. If they are equal, loop end flag will be set to true and exits the loop. RACCU has a computation unit which is similar to a mini-DPU. It has 5 working modes. All of them are binary operations. They are: (0) RACCU_MODE_IDLE (1) RACCU_MODE_LOOP_H (2) RACCU_MODE_LOOP_T (3) RACCU_MODE_ADD (4) RACCU_MODE_SUB (5) RACCU_MODE_SHIFT_L (6) RACCU_MODE_SHIFT_R (7) RACCU_MODE_ADD_WITH_LOOP_INDEX Operands of each mode can be either immediate value from instruction or data from RACCU register whoes address is specified by the instruction. A bit is used to distinguish the operand origin. Info New RACCU implementation. RACCU is a unit inside Sequencer. It has a register file of default depth N=8 . Contraints, temporary variables and loop iterators will be stored inside this register file. The data register is always exposed to Sequencer to read. Loop iterator will be assigned from the beginning of the register file according to the order of loop while RACCU variables will be assigned from the end of register file. Once the loop iterators or the RACCU variables are not needed, they can be freed by moving the stack/heap pointer 1 position back. The assignment of register location is managed by the Vesyla compiler. RACCU has a computation unit which is similar to a mini-DPU. It has 8 working modes. All of them are binary operations. They are: (0) RACCU_MODE_IDLE (1) RACCU_MODE_LOOP_H (2) RACCU_MODE_LOOP_T (3) RACCU_MODE_ADD (4) RACCU_MODE_SUB (5) RACCU_MODE_SHIFT_L (6) RACCU_MODE_SHIFT_R (7) RACCU_MODE_LOG2 Operands of each mode can be either immediate value from instruction or data from RACCU register whoes address is specified by the instruction. A bit is used to distinguish the operand origin.","title":"Specification"},{"location":"Docs/Fabric/DRRA/RACCU/#related-instructions","text":"","title":"Related Instructions"},{"location":"Docs/Fabric/DRRA/RACCU/#raccu-instruction","text":"","title":"RACCU instruction"},{"location":"Docs/Fabric/DRRA/RACCU/#loop_header-instruction","text":"","title":"LOOP_HEADER instruction"},{"location":"Docs/Fabric/DRRA/RACCU/#loop_tail-instruction","text":"Info Old RACCU implementation. Signal I/O Type Description clk in std_logic Clock rst in std_logic Reset, active low op1_sd in std_logic Type of operand 1, 0-immediate, 1-reference op1 in std_logic_vector 8bits Operand 1 value / Operand 1 address op2_sd in std_logic Type of operand 2, 0-immediate, 1-reference op2 in std_logic_vector 8bits Operand 2 value / Operand 2 address cfg_mode in std_logic_vector 3bits Mode of RACCU computation unit result_addr in std_logic_vector 3bits Result address in data_reg data_reg out raccu_reg_out_ty Data register output loop_reg out raccu_loop_array_ty Loop register output Info New RACCU implementation. Signal I/O Type Description clk in std_logic Clock rst in std_logic Reset, active low op1_sd in std_logic Type of operand 1, 0-immediate, 1-reference op1 in std_logic_vector 8bits Operand 1 value / Operand 1 address op2_sd in std_logic Type of operand 2, 0-immediate, 1-reference op2 in std_logic_vector 8bits Operand 2 value / Operand 2 address cfg_mode in std_logic_vector 3bits Mode of RACCU computation unit result_addr in std_logic_vector 3bits Result address in data_reg data_reg out raccu_reg_out_ty Data register output","title":"LOOP_TAIL instruction"},{"location":"Docs/Fabric/RISCV/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/Library/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/Library/BLAS/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/Library/BLAS/L3/gemm/","text":"GEMM Function gemm computes a matrix-matrix product with general matrices. The gemm routines compute a scalar-matrix-matrix product and add the result to a scalar-matrix product, with general matrices. The operation is defined as C \\leftarrow \\alpha *A*B + \\beta *C C \\leftarrow \\alpha *A*B + \\beta *C where: \\alpha \\alpha and \\beta \\beta are scalars, A A , B B and C C are matrices: A A is an m-by-k matrix, B B is a k-by-n matrix, C C is an m-by-n matrix. Parameters m m : The number of rows in A A and C C . k k : The number of columns in A A and the number of rows in B B . n n : The number of columns in C C . Mapping One-Column Mapping Memory Mapping m m , k k and n n are multiple of DiMArch row width (16). A A and C C stored in DiMArch in row-major fashion and B B stored in DiMArch in col-major fashion. The first 16 words in register file in DRRA cell [0,0] is reserved for elements in A A . The second half register file (16 words) is reserved for elements in B B . The first 16 words in register file in DRRA cell [1,0] is for elements in C C . The register space for A A is also used temporarily for storing \\alpha \\alpha and \\beta \\beta . One of the internal register in DRRA cell [0,0] is also used for holding \\alpha \\alpha in order to perform the axpy() function. Function Mapping Scaling Cost Metrics","title":"GEMM"},{"location":"Docs/Library/BLAS/L3/gemm/#gemm","text":"","title":"GEMM"},{"location":"Docs/Library/BLAS/L3/gemm/#function","text":"gemm computes a matrix-matrix product with general matrices. The gemm routines compute a scalar-matrix-matrix product and add the result to a scalar-matrix product, with general matrices. The operation is defined as C \\leftarrow \\alpha *A*B + \\beta *C C \\leftarrow \\alpha *A*B + \\beta *C where: \\alpha \\alpha and \\beta \\beta are scalars, A A , B B and C C are matrices: A A is an m-by-k matrix, B B is a k-by-n matrix, C C is an m-by-n matrix.","title":"Function"},{"location":"Docs/Library/BLAS/L3/gemm/#parameters","text":"m m : The number of rows in A A and C C . k k : The number of columns in A A and the number of rows in B B . n n : The number of columns in C C .","title":"Parameters"},{"location":"Docs/Library/BLAS/L3/gemm/#mapping","text":"","title":"Mapping"},{"location":"Docs/Library/BLAS/L3/gemm/#one-column-mapping","text":"","title":"One-Column Mapping"},{"location":"Docs/Library/BLAS/L3/gemm/#memory-mapping","text":"m m , k k and n n are multiple of DiMArch row width (16). A A and C C stored in DiMArch in row-major fashion and B B stored in DiMArch in col-major fashion. The first 16 words in register file in DRRA cell [0,0] is reserved for elements in A A . The second half register file (16 words) is reserved for elements in B B . The first 16 words in register file in DRRA cell [1,0] is for elements in C C . The register space for A A is also used temporarily for storing \\alpha \\alpha and \\beta \\beta . One of the internal register in DRRA cell [0,0] is also used for holding \\alpha \\alpha in order to perform the axpy() function.","title":"Memory Mapping"},{"location":"Docs/Library/BLAS/L3/gemm/#function-mapping","text":"","title":"Function Mapping"},{"location":"Docs/Library/BLAS/L3/gemm/#scaling","text":"","title":"Scaling"},{"location":"Docs/Library/BLAS/L3/gemm/#cost-metrics","text":"","title":"Cost Metrics"},{"location":"Docs/Library/FFT/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/Library/Interleaver/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/Library/NN/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/Start/Overview/","text":"Getting start Source code Find the source code Source code organization Read and contribute to the source code Quick guide for code documentation Quick guide for naming system","title":"Getting start"},{"location":"Docs/Start/Overview/#getting-start","text":"","title":"Getting start"},{"location":"Docs/Start/Overview/#source-code","text":"","title":"Source code"},{"location":"Docs/Start/Overview/#find-the-source-code","text":"Source code organization","title":"Find the source code"},{"location":"Docs/Start/Overview/#read-and-contribute-to-the-source-code","text":"Quick guide for code documentation Quick guide for naming system","title":"Read and contribute to the source code"},{"location":"Docs/Start/Quick-guide-for-code-documentation/","text":"Warning Documentation is not complete! Quick guide for code documentation SiLago project try to use doxygen to generate reference manual for its source code. The comment is crutial for the quality of generated documentation. Therefore, we make some guidelines for commenting the source code. C++ Comment environment Use QT's commenting style to form a doxygen readable comment block. As shown in the example below. 1 2 3 /*! * This is a block comment */ Single line comment is also allowed and should using style like this: 1 //! This is a single line comment Comment a file Every header file should be documented with a short description about the role of this file. Additional information like author, license, modification history, etc should also be included inside the comment block. Example: 1 2 3 4 5 6 7 8 9 10 11 12 /*! * \\file Global.hpp * * Defines all the global variables. * * Author: author <author@domain.com> * Licese: MIT * Modification: * 2017-01-03 author created * 2017-02-05 user1 add feature of xxx * 2017-02-07 user2 fix bug xxx */ Comment a class Every class should be documented right before its defination. Description of the function of the class is very important. Example: 1 2 3 4 5 6 /*! * Description of class A */ class A : public B { .... }; Comment a method/function Method function should be documented right before its declaration. The description, parameters, return type should be included inside the comment block. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A : public B { public : /*! * Constructor */ A (); /*! * Some other function * * \\param p0 some input * \\param p1 the second input * \\return the calculate result */ int func ( int p0 , int p1 ); };","title":"Quick guide for code documentation"},{"location":"Docs/Start/Quick-guide-for-code-documentation/#quick-guide-for-code-documentation","text":"SiLago project try to use doxygen to generate reference manual for its source code. The comment is crutial for the quality of generated documentation. Therefore, we make some guidelines for commenting the source code.","title":"Quick guide for code documentation"},{"location":"Docs/Start/Quick-guide-for-code-documentation/#c","text":"","title":"C++"},{"location":"Docs/Start/Quick-guide-for-code-documentation/#comment-environment","text":"Use QT's commenting style to form a doxygen readable comment block. As shown in the example below. 1 2 3 /*! * This is a block comment */ Single line comment is also allowed and should using style like this: 1 //! This is a single line comment","title":"Comment environment"},{"location":"Docs/Start/Quick-guide-for-code-documentation/#comment-a-file","text":"Every header file should be documented with a short description about the role of this file. Additional information like author, license, modification history, etc should also be included inside the comment block. Example: 1 2 3 4 5 6 7 8 9 10 11 12 /*! * \\file Global.hpp * * Defines all the global variables. * * Author: author <author@domain.com> * Licese: MIT * Modification: * 2017-01-03 author created * 2017-02-05 user1 add feature of xxx * 2017-02-07 user2 fix bug xxx */","title":"Comment a file"},{"location":"Docs/Start/Quick-guide-for-code-documentation/#comment-a-class","text":"Every class should be documented right before its defination. Description of the function of the class is very important. Example: 1 2 3 4 5 6 /*! * Description of class A */ class A : public B { .... };","title":"Comment a class"},{"location":"Docs/Start/Quick-guide-for-code-documentation/#comment-a-methodfunction","text":"Method function should be documented right before its declaration. The description, parameters, return type should be included inside the comment block. Example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class A : public B { public : /*! * Constructor */ A (); /*! * Some other function * * \\param p0 some input * \\param p1 the second input * \\return the calculate result */ int func ( int p0 , int p1 ); };","title":"Comment a method/function"},{"location":"Docs/Start/Quick-guide-for-naming-system/","text":"Warning Documentation is not complete!","title":"Quick guide for naming system"},{"location":"Docs/Start/Source-code-organization/","text":"Warning Documentation is not complete!","title":"Source code organization"},{"location":"Docs/ToolChain/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/ToolChain/Sylva/Overview/","text":"Sylva New version of Sylva documentation: Sylva documentation","title":"Sylva"},{"location":"Docs/ToolChain/Sylva/Overview/#sylva","text":"New version of Sylva documentation: Sylva documentation","title":"Sylva"},{"location":"Docs/ToolChain/Vesyla/Cadfg/","text":"CADFG - Control Address Data-Flow Graph CADFG is a DAG(directed acyclic graph)-based data structure used as an intermediate representation (IR) by Vesyla. Conventional High-level synthesis (HLS) tools typically model high-level program as control and dataflow graph (CDFG) as the intermediate representation (IR). This representation was appropriate because HLS tools synthesize an FSMD (FSM+Datapath) as the target architecture, deal with scalars and do not differentiate between functional, address and address constraints computation. Vesyla-II, in contrast generates distributed two-level FSM control scheme, deals with vectors and differentiates between the three categories of computation. These differences are reflected in the the IR used by Vesyla-II called Control, Address and Dataflow Graph (CADFG). CADFG is derived from the abstract syntax tree (AST). By a series of refinement, it transforms to Instruction Dependent Graph (IDG) as the back-end IR. In this section, we focus on elaborating some of the critical vertices of CADFG. Vertices There are several broad categories of vertices in CADFG: Source and Sink vertices : create and terminate data flow. Read and Write vertices : slice vector to scalar and pack scalar to vector. Address and Address Constraint vertices : generates the address sequence for slicing and packing and address constraints. Function vertex : does general data computation. Control vertices : handle branches and loops. Source and Sink Vertices Source vertices doesn't have any input port and sink vertices doesn't have any output port. Both types of vertices support both vector and scalar data type. In figure ??, p1 to p5 and X are all source vertices, while y is sink vertex. Read and Write Vertices Read vertex slices the vector variable to its each individual element and sending out them one at a time. On the contrary, write vertex packs the time distributed scalar data sequence to vector variable. Both vertices need an address vertex attach to them in order to decide the address sequence. In figure ??, vertex R is an example of read vertex. Address and Address Constraint Vertices Address and Address Constraint Vertices are the key differentiator compared to conventional CDFGs. These vertices embody the policy of differentiating address and address constraints as separate computation category and mapping them to dedicated spatially distributed resources. This manifests in the read vertex getting its addresses from a function that models the address computation as a two-level affine function with five operands as shown and explained with an example in Figure ??. An implication of such an address function is that read vertex does not read a scalar but a vector. The address constraints are also explicitly identified to enable their computation to be also mapped to custom spatially distributed computation resource. In following figure, vertex A is an address vertex. When Vesyla encounters higher order address functions beyond two levels affine function, it repeatedly computes the constraints of the inner two-level loops in a pipelined fashion. Computation in pipelined fashion deserves some explanation. Let us call one instance of innermost two loops as an epoch. While the functional computation and address computation of the innermost two loops are working on epoch i, the address constraints for the next epoch, i+1, are computed in parallel on an independent machine as shown in the following figure. Function Vertex Function vertices are responsible for the actual computation on input data. They are usually bind to arithmetic units inside DRRA cells. Function vertices only accept scalar inputs and generate scalar outputs. That's why we have the read and write nodes to break down the vector variables. Function vertex can be chained together to form more complex arithmetic operation. Control Vertex Control vertices model the control hierarchy and in this respective they are similar to the control vertices in typical CDFGs. These vertices model the main algorithmic level control and not the control for fine grained address and address constraints computation. In CADFG, we do not have explicit control edges to model control dependencies. This is implicitly represented by the hierarchy of the control blocks. All nodes inside a control block are implicitly triggered if the control condition and the data dependency condition of the control block is fulfilled. When an algorithm is parallelized, parts of control hierarchy are replicated to represent the parallelism. Loops in Vesyla are not dynamic, they are either compile time or parametrically static. The latter implies that once the parameter for the loop bounds and increment are decided, these parameters remain static until the loop is complete. The dedicated resources for address constraints computation also serve to manage the loop parameters or constraints. For this reason, CADFG loop vertices are composite, i.e., they do not have any separate datapath vertex for loop condition comparison. Typical HLS tools, on the other hand, instantiate comparators and incrementors/adders to implement loop control verteices. Control Vertices include branch vertex, loop vertex, merge vertex, etc. Edges There are two broad categories of edges in CADFG: Dataflow edge : represents the flow of data, either scalar or vector. Dependency edge : represents the dependency relation between the predicessor and successor. Dataflow Edge Like in conventional CDFG, dataflow edge shows the flow of data. It's a directed edge with predicessor and successor. Data flows from predicessor to successor. Dataflow edge can be either scalar or vector. Dataflow edge automatically embeds the information of dependency. The successor cannot be scheduled earlier than the predicessor. Dependency Edge Dependency edge is a more sophiscated way to describe dependencies among vertices. Vesyla uses dependency edges because in order to solve some hazzards such as \"WAR\" and \"WAW\", extra dependency information is needed and these information can't be provided by normal dataflow edges. A dependency edge is also a directed edge. A timing period is associated with each dependency edge to indicate that the successor should start after the predicessor after some time t t and t t should be bounded by the timing period associated with the dependency edge. Each terminal of the edge also has a property indicating the moment the dependency edge will start to apply. The property can be PROCESS BEGIN or PROCESS END . Thus, a dependency edge a \\rightarrow{} b a \\rightarrow{} b can express 4 different types of dependencies. b b starts after a a starts. b b starts after a a ends. b b ends after a a starts. b b ends after a a ends. Example Lines 1 to 4 are the symbolic parameters that control the dimension of the algorithm and also the allocation and binding. These parameters influence the dimension of the CADFG. For instance, the parameter Col decides the degree of parallelism. The CADFG shown in figure corresponds to Col=1 case. If Col > 1, Vesyla would replicate the CADFG Col times to represent the parallelism. Lines 5 to 8 define the allocation and binding for the storage. This information is stored as attributes in the source and destination nodes of the read/write nodes in the CADFG. Lines 9 to 16 decide the dimension and structure of the CADFG. The control hierarchy is represented by hierarchy of control blocks that serves as containers. In CADFG, there are no explicit control arcs but being inside a control block implies having a control arc from the parent control block. Line 9 refers to spatial iteration, i.e., parallelism and as stated above, decides the number of replications of CADFG. Line 10 is the highest control node that will be executed in each thread; CADFG in figure has a single thread with Col=1. Inside this control block, there are three sub-control blocks, each representing a vector operation on lines 11, 12 and 14. Two of these control blocks enclose read nodes and one write node. Besides these three read/write nodes, there is a functional computation node to represent the functionality on line 13. The read/write nodes that model the vector movement in lines 11, 12 and 14 all have the address and address constraints computation nodes for both LHS and RHS. Potentially, all three nodes could involve three sets of spatially distributed FSMs for address and address computations. Later, factoring in the allocation, binding and the data dependenncies, Vesyla synthesizes strucutures and details for scheduling and synchronizing these FSMs, some of them could be mapped to the same FSM. A simplification process in Vesyla transforms the symbolic expressions in Matlab to numerical values for loop and address constraints. A boxed note in figure explains one such example for address constraints for LHS of line 11. In the example under consideration, there is only one functional computation node on line 13 and as can be seen its inputs and outputs are also vectorizing read/write nodes. Also, the functional computational node is also associated with an allocation and binding pragmas that is duly recorded as part of building the CADFG. While building the CADFG, Vesyla, like other HLS tools also creates explicit data dependencies that crosses control block boundaries. Vesyla also detect hazards and records them with additional dependency arcs. This is explained next.","title":"CADFG - Control Address Data-Flow Graph"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#cadfg-control-address-data-flow-graph","text":"CADFG is a DAG(directed acyclic graph)-based data structure used as an intermediate representation (IR) by Vesyla. Conventional High-level synthesis (HLS) tools typically model high-level program as control and dataflow graph (CDFG) as the intermediate representation (IR). This representation was appropriate because HLS tools synthesize an FSMD (FSM+Datapath) as the target architecture, deal with scalars and do not differentiate between functional, address and address constraints computation. Vesyla-II, in contrast generates distributed two-level FSM control scheme, deals with vectors and differentiates between the three categories of computation. These differences are reflected in the the IR used by Vesyla-II called Control, Address and Dataflow Graph (CADFG). CADFG is derived from the abstract syntax tree (AST). By a series of refinement, it transforms to Instruction Dependent Graph (IDG) as the back-end IR. In this section, we focus on elaborating some of the critical vertices of CADFG.","title":"CADFG - Control Address Data-Flow Graph"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#vertices","text":"There are several broad categories of vertices in CADFG: Source and Sink vertices : create and terminate data flow. Read and Write vertices : slice vector to scalar and pack scalar to vector. Address and Address Constraint vertices : generates the address sequence for slicing and packing and address constraints. Function vertex : does general data computation. Control vertices : handle branches and loops.","title":"Vertices"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#source-and-sink-vertices","text":"Source vertices doesn't have any input port and sink vertices doesn't have any output port. Both types of vertices support both vector and scalar data type. In figure ??, p1 to p5 and X are all source vertices, while y is sink vertex.","title":"Source and Sink Vertices"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#read-and-write-vertices","text":"Read vertex slices the vector variable to its each individual element and sending out them one at a time. On the contrary, write vertex packs the time distributed scalar data sequence to vector variable. Both vertices need an address vertex attach to them in order to decide the address sequence. In figure ??, vertex R is an example of read vertex.","title":"Read and Write Vertices"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#address-and-address-constraint-vertices","text":"Address and Address Constraint Vertices are the key differentiator compared to conventional CDFGs. These vertices embody the policy of differentiating address and address constraints as separate computation category and mapping them to dedicated spatially distributed resources. This manifests in the read vertex getting its addresses from a function that models the address computation as a two-level affine function with five operands as shown and explained with an example in Figure ??. An implication of such an address function is that read vertex does not read a scalar but a vector. The address constraints are also explicitly identified to enable their computation to be also mapped to custom spatially distributed computation resource. In following figure, vertex A is an address vertex. When Vesyla encounters higher order address functions beyond two levels affine function, it repeatedly computes the constraints of the inner two-level loops in a pipelined fashion. Computation in pipelined fashion deserves some explanation. Let us call one instance of innermost two loops as an epoch. While the functional computation and address computation of the innermost two loops are working on epoch i, the address constraints for the next epoch, i+1, are computed in parallel on an independent machine as shown in the following figure.","title":"Address and Address Constraint Vertices"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#function-vertex","text":"Function vertices are responsible for the actual computation on input data. They are usually bind to arithmetic units inside DRRA cells. Function vertices only accept scalar inputs and generate scalar outputs. That's why we have the read and write nodes to break down the vector variables. Function vertex can be chained together to form more complex arithmetic operation.","title":"Function Vertex"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#control-vertex","text":"Control vertices model the control hierarchy and in this respective they are similar to the control vertices in typical CDFGs. These vertices model the main algorithmic level control and not the control for fine grained address and address constraints computation. In CADFG, we do not have explicit control edges to model control dependencies. This is implicitly represented by the hierarchy of the control blocks. All nodes inside a control block are implicitly triggered if the control condition and the data dependency condition of the control block is fulfilled. When an algorithm is parallelized, parts of control hierarchy are replicated to represent the parallelism. Loops in Vesyla are not dynamic, they are either compile time or parametrically static. The latter implies that once the parameter for the loop bounds and increment are decided, these parameters remain static until the loop is complete. The dedicated resources for address constraints computation also serve to manage the loop parameters or constraints. For this reason, CADFG loop vertices are composite, i.e., they do not have any separate datapath vertex for loop condition comparison. Typical HLS tools, on the other hand, instantiate comparators and incrementors/adders to implement loop control verteices. Control Vertices include branch vertex, loop vertex, merge vertex, etc.","title":"Control Vertex"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#edges","text":"There are two broad categories of edges in CADFG: Dataflow edge : represents the flow of data, either scalar or vector. Dependency edge : represents the dependency relation between the predicessor and successor.","title":"Edges"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#dataflow-edge","text":"Like in conventional CDFG, dataflow edge shows the flow of data. It's a directed edge with predicessor and successor. Data flows from predicessor to successor. Dataflow edge can be either scalar or vector. Dataflow edge automatically embeds the information of dependency. The successor cannot be scheduled earlier than the predicessor.","title":"Dataflow Edge"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#dependency-edge","text":"Dependency edge is a more sophiscated way to describe dependencies among vertices. Vesyla uses dependency edges because in order to solve some hazzards such as \"WAR\" and \"WAW\", extra dependency information is needed and these information can't be provided by normal dataflow edges. A dependency edge is also a directed edge. A timing period is associated with each dependency edge to indicate that the successor should start after the predicessor after some time t t and t t should be bounded by the timing period associated with the dependency edge. Each terminal of the edge also has a property indicating the moment the dependency edge will start to apply. The property can be PROCESS BEGIN or PROCESS END . Thus, a dependency edge a \\rightarrow{} b a \\rightarrow{} b can express 4 different types of dependencies. b b starts after a a starts. b b starts after a a ends. b b ends after a a starts. b b ends after a a ends.","title":"Dependency Edge"},{"location":"Docs/ToolChain/Vesyla/Cadfg/#example","text":"Lines 1 to 4 are the symbolic parameters that control the dimension of the algorithm and also the allocation and binding. These parameters influence the dimension of the CADFG. For instance, the parameter Col decides the degree of parallelism. The CADFG shown in figure corresponds to Col=1 case. If Col > 1, Vesyla would replicate the CADFG Col times to represent the parallelism. Lines 5 to 8 define the allocation and binding for the storage. This information is stored as attributes in the source and destination nodes of the read/write nodes in the CADFG. Lines 9 to 16 decide the dimension and structure of the CADFG. The control hierarchy is represented by hierarchy of control blocks that serves as containers. In CADFG, there are no explicit control arcs but being inside a control block implies having a control arc from the parent control block. Line 9 refers to spatial iteration, i.e., parallelism and as stated above, decides the number of replications of CADFG. Line 10 is the highest control node that will be executed in each thread; CADFG in figure has a single thread with Col=1. Inside this control block, there are three sub-control blocks, each representing a vector operation on lines 11, 12 and 14. Two of these control blocks enclose read nodes and one write node. Besides these three read/write nodes, there is a functional computation node to represent the functionality on line 13. The read/write nodes that model the vector movement in lines 11, 12 and 14 all have the address and address constraints computation nodes for both LHS and RHS. Potentially, all three nodes could involve three sets of spatially distributed FSMs for address and address computations. Later, factoring in the allocation, binding and the data dependenncies, Vesyla synthesizes strucutures and details for scheduling and synchronizing these FSMs, some of them could be mapped to the same FSM. A simplification process in Vesyla transforms the symbolic expressions in Matlab to numerical values for loop and address constraints. A boxed note in figure explains one such example for address constraints for LHS of line 11. In the example under consideration, there is only one functional computation node on line 13 and as can be seen its inputs and outputs are also vectorizing read/write nodes. Also, the functional computational node is also associated with an allocation and binding pragmas that is duly recorded as part of building the CADFG. While building the CADFG, Vesyla, like other HLS tools also creates explicit data dependencies that crosses control block boundaries. Vesyla also detect hazards and records them with additional dependency arcs. This is explained next.","title":"Example"},{"location":"Docs/ToolChain/Vesyla/DeadCodeElimination/","text":"","title":"DeadCodeElimination"},{"location":"Docs/ToolChain/Vesyla/DependencyAnalysis/","text":"Dependency Analysis Dependencies created in CADFG don't take the address range of vector variable read/write operations into account. To add such information and fine tune the dependencies, we need to have this dependency analysis process. Here, dependency analysis only refers to the dependency checking for vector operations. Data dependencies between vector variables are more complex than scalar variables because it not only involves the variables but also their read and write access patterns. There are many sophisticated techniques to analyse dependencies among vector operations. Many great works have been done in this research field. However, Vesyla, as a proof-of-concept tool, doesn\u2019t explore all those advanced methods for optimization purpose. It broadly categorizes data dependency among vector variables as strong dependency , weak dependency and fake dependency . Strong dependency requires the successor starts no earlier than the end of its predecessor. Weak dependency only requires the successor starts no earlier than the start of its predecessor. Fake dependency indicates there is no actual data hazard between predecessor and successor, the dependency edge can be removed. As shown in the following figure, If the predecessor and successor of a dependency edge has non-overlapping access patterns the dependency edge is fake because the two nodes will never access the same location. If the predecessor and successor have the same pattern or the successor has a pattern that is a simple shift of the predecessor pattern, the dependency is weak because the predecessor will always access the location before the successor, thus the successor can start one cycle later than the starting of predecessor. For all other cases, Vesyla-II considers the dependency edge strong since this is the most conservative assumption.","title":"Dependency Analysis"},{"location":"Docs/ToolChain/Vesyla/DependencyAnalysis/#dependency-analysis","text":"Dependencies created in CADFG don't take the address range of vector variable read/write operations into account. To add such information and fine tune the dependencies, we need to have this dependency analysis process. Here, dependency analysis only refers to the dependency checking for vector operations. Data dependencies between vector variables are more complex than scalar variables because it not only involves the variables but also their read and write access patterns. There are many sophisticated techniques to analyse dependencies among vector operations. Many great works have been done in this research field. However, Vesyla, as a proof-of-concept tool, doesn\u2019t explore all those advanced methods for optimization purpose. It broadly categorizes data dependency among vector variables as strong dependency , weak dependency and fake dependency . Strong dependency requires the successor starts no earlier than the end of its predecessor. Weak dependency only requires the successor starts no earlier than the start of its predecessor. Fake dependency indicates there is no actual data hazard between predecessor and successor, the dependency edge can be removed. As shown in the following figure, If the predecessor and successor of a dependency edge has non-overlapping access patterns the dependency edge is fake because the two nodes will never access the same location. If the predecessor and successor have the same pattern or the successor has a pattern that is a simple shift of the predecessor pattern, the dependency is weak because the predecessor will always access the location before the successor, thus the successor can start one cycle later than the starting of predecessor. For all other cases, Vesyla-II considers the dependency edge strong since this is the most conservative assumption.","title":"Dependency Analysis"},{"location":"Docs/ToolChain/Vesyla/DiMArch/","text":"Error : [Errno 2] No such file or directory: 'dot': 'dot' : ['dot', '-Tpng'] digraph G { subgraph cluster_route{ label=\"ROUTE\" route_issue [label=\"issue\"]; route_end [label=\"end\"]; route_issue -> route_end [label=\">0\"] } subgraph cluster_sram{ label=\"SRAM_R\" sram_issue [label=\"issue\"]; sram_arrive [label=\"arrive\"]; sram_active [label=\"active\"]; sram_end [label=\"end\"]; sram_issue -> sram_arrive [label=\"=(#hop+1)\"]; sram_arrive -> sram_active [label=\"=0\"]; sram_active -> sram_end [label=\"=#element\"]; } subgraph cluster_refi{ label=\"REFI\" refi_issue [label=\"issue\"]; refi_active [label=\"active\"]; refi_end [label=\"end\"]; refi_issue -> refi_active [label=\">=0\"]; refi_active -> refi_end [label=\"=#element\"]; } route_issue -> sram_issue [label=\">0\"]; route_issue -> refi_issue [label=\">0\"]; sram_end -> route_end [label=\">=0\"]; refi_end -> route_end [label=\">=0\"]; sram_active -> refi_active[label=\"=#hop\"] }","title":"DiMArch Reading and Writing"},{"location":"Docs/ToolChain/Vesyla/ExpressionSimplification/","text":"Expression Simplification Algorithm Perserving Dependency Edges","title":"Expression Simplification"},{"location":"Docs/ToolChain/Vesyla/ExpressionSimplification/#expression-simplification","text":"","title":"Expression Simplification"},{"location":"Docs/ToolChain/Vesyla/ExpressionSimplification/#algorithm","text":"","title":"Algorithm"},{"location":"Docs/ToolChain/Vesyla/ExpressionSimplification/#perserving-dependency-edges","text":"","title":"Perserving Dependency Edges"},{"location":"Docs/ToolChain/Vesyla/Hazzard/","text":"Hazard Here we only talk about data hazards. Standard Hazards A data hazard is created whenever there is a dependence between data read and/or write operations. Without such dependency information perserved by some proper format, the data access order might be different from the intended order expressed by the programmer in source code thus might lead to unintended output. The goal of harzard detection is to exploit parallesism by perserving data access order only where it affects the outcome of the program. Data hazard can be categorized as Read-After-Write (RAW), Write-After-Write (WAW) and Write-After-Read (WAR). For out-of-order issue hardware or compiler that exploits instruction execution order all three types of hazard can happen. Therefore, we need to preserve the dependency information in order to avoid those hazards. Hazards in Vector Machine and Vesyla In vesyla, the case for RAW is simple. It will be directly absorbed by the data dependency edge that is anyway created. WAR and WAW, requires creation of additional special edges to indicate that there are data dependencies. Data hazards for vector variables are different from those for scalar variables. For example, in the following figure, a WAW dependency is not necessary for scalar variables because the first \u201cWrite\u201d operation can\u2019t affect the final result of that scalar variable hence can be directly removed. While for vector variables, WAW dependency is absolutely necessary, because those two \u201cWrite\u201d operations might write to different part of the vector therefore both will influence the final result of the vector variable. Different from scalar machine, vector machine need extra information to create dependencies. Vector operations usually last for some time period. The dependencies between vector operations need to specify which timing point they are referring to. Specifically, the start and end time of a vector operation are important. Regarding just start and end time of vector operations, we can create 4 types of dependencies: Dependency between the start of predicessor and the start of successor. Dependency between the start of predicessor and the end of successor. Dependency between the end of predicessor and the start of successor. Dependency between the end of predicessor and the end of successor. Data dependency analysis technique can be found in section Dependency Analysis .","title":"Hazard"},{"location":"Docs/ToolChain/Vesyla/Hazzard/#hazard","text":"Here we only talk about data hazards.","title":"Hazard"},{"location":"Docs/ToolChain/Vesyla/Hazzard/#standard-hazards","text":"A data hazard is created whenever there is a dependence between data read and/or write operations. Without such dependency information perserved by some proper format, the data access order might be different from the intended order expressed by the programmer in source code thus might lead to unintended output. The goal of harzard detection is to exploit parallesism by perserving data access order only where it affects the outcome of the program. Data hazard can be categorized as Read-After-Write (RAW), Write-After-Write (WAW) and Write-After-Read (WAR). For out-of-order issue hardware or compiler that exploits instruction execution order all three types of hazard can happen. Therefore, we need to preserve the dependency information in order to avoid those hazards.","title":"Standard Hazards"},{"location":"Docs/ToolChain/Vesyla/Hazzard/#hazards-in-vector-machine-and-vesyla","text":"In vesyla, the case for RAW is simple. It will be directly absorbed by the data dependency edge that is anyway created. WAR and WAW, requires creation of additional special edges to indicate that there are data dependencies. Data hazards for vector variables are different from those for scalar variables. For example, in the following figure, a WAW dependency is not necessary for scalar variables because the first \u201cWrite\u201d operation can\u2019t affect the final result of that scalar variable hence can be directly removed. While for vector variables, WAW dependency is absolutely necessary, because those two \u201cWrite\u201d operations might write to different part of the vector therefore both will influence the final result of the vector variable. Different from scalar machine, vector machine need extra information to create dependencies. Vector operations usually last for some time period. The dependencies between vector operations need to specify which timing point they are referring to. Specifically, the start and end time of a vector operation are important. Regarding just start and end time of vector operations, we can create 4 types of dependencies: Dependency between the start of predicessor and the start of successor. Dependency between the start of predicessor and the end of successor. Dependency between the end of predicessor and the start of successor. Dependency between the end of predicessor and the end of successor. Data dependency analysis technique can be found in section Dependency Analysis .","title":"Hazards in Vector Machine and Vesyla"},{"location":"Docs/ToolChain/Vesyla/Idg/","text":"IDG - Instruction Dependency Graph","title":"IDG - Instruction Dependency Graph"},{"location":"Docs/ToolChain/Vesyla/Idg/#idg-instruction-dependency-graph","text":"","title":"IDG - Instruction Dependency Graph"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/","text":"Warning Documentation is not complete! Instruction Set Instructions 0001 - REFI1 1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 0 0 1 A A B B C D D D D D D E F F F F F F G H H H H Field Position Width Range/Value Description instr_code [26, 23] 4 b'0001 REFI1 instruction code reg_file_port [22, 21] 2 [0, 3] Selects one of the RFile ports subseq_instrs [20, 19] 2 [0, 3] The instruction decoder fetches the consequent (REFI1) or (REFI1 and REFI2) instructions. start_addrs_sd 18 1 [0, 1] The start_addrs is valid only if the start_addrs_sd is 0. Otherwise the start_address would be taken from the RACCU register start_addrs [17, 12] 6 [0, 63] Configures the starting address for the AGU no_of_addrs_sd 11 1 [0, 1] The no_of_addrs is valid only when no_of_addrs_sd is 0, otherwise the no_of_addrs would be taken from the RACCU register. no_of_addrs [10, 5] 6 [0, 63] Configures the number of address for the AGU initial_delay_sd: 4 1 [0, 1] The init_delay is valid only when init_delay_sd is set. initial_delay [3, 0] 4 [0, 15] Configures the initial delay 0010 - REFI2 1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 0 1 0 A B B B B B B C D E E E E F G G G G G H H H H Field Position Width Range/Value Description instr_code [26, 23] 4 b'0010 REFI2 instruction code step_val_sd 22 1 [0, 1] The step_val is valid only if step_val_sd is set. step_val [21, 16] 6 [0, 63] Step incremental/decremental value of the address step_val_sign 15 1 [0, 1] If it's 0, address will be incremented by the step_val else decremented by the step_val refi_middle_delay_sd 14 1 [0, 63] The refi_middle_delay is valid only if refi_middle_delay_sd is 0 refi_middle_delay [13, 10] 4 [0, 15] Configures the middle dealy no_of_reps_sd 9 1 [0, 1] The no_of_reps is valid only when the no_of_reps_sd is 0, otherwise the no_of_reps value would be taken from the RACCU register no_of_reps [8, 4] 5 [0, 31] Configures the number of times the address pattern to repeat rpt_step_value [3, 0] 4 [0, 15] The step increment/decrement value 0011 - REFI3 0100 - DPU 1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 1 0 0 A A A A A B B C C D D E F G G G G G G G G H H Field Position Width Range/Value Description instr_code [26, 23] 4 b'0100 DPU instruction code dpu_mode [22, 18] 5 [0, 12] Configures the valid dpu mode dpu_saturation [17, 16] 2 [0, 3] Selects the integer or fixed point operation with or without saturation 1 dpu_output_a [15, 14] 2 [0, 3] Selects one or both the outports 2 dpu_output_b [13, 12] 2 [0, 3] Selects one or both the outports 2 dpu_acc_clear_rst 11 1 [0, 1] Asynchronous reset, when set, clears the DPU accumulator register. dpu_acc_clear_sd 10 1 [0, 1] The dpu_acc_clear is valid only when dpu acc_clear_sd is set. dpu_acc_clear [9, 2] 8 [0, 255] The DPU accumulator register is cleared when the accumulator counter reaches the value configured in the dpu_acc_clear dpu_process_inout [1, 0] 2 [0, 3] Processes the input or output 3 0101 SWB Warning SWB is not a direct mapping instruction. It need to be re-interpret by RTL fabric. Field Position Width Range/Value Description instr_code [26, 23] 4 b'0110 SWB instruction code source_row N/A N/A N/A The source DRRA row source_col [16, 0] 17 N/A The source DRRA column 0110 JUMP 1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 1 1 0 A A A A A A - - - - - - - - - - - - - - - - - Field Position Width Range/Value Description instr_code [26, 23] 4 b'0110 JUMP instruction code true_addrs [22, 17] 6 4 [0, 63] The target address N/A [16, 0] 17 N/A N/A 0111 DELAY 1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 1 1 1 A B B B B B B B B B B B B B B B - - - - - - - Field Position Width Range/Value Description instr_code [26, 23] 4 b'0111 DELAY instruction code del_cycles_sd 22 1 [0, 1] The del_cycles is valid only if del_cycles_sd is set del_cycles [21, 7] 15 [0, 32767] Number of clock cycles to wait before decoding the next instruction N/A [6, 0] 7 N/A N/A 1000 FOR_HEADER 1001 FOR_TAIL 1010 RACCU 1011 BRANCH 1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 1 1 1 A A B B B B B B - - - - - - - - - - - - - - - Field Position Width Range/Value Description instr_code [26, 23] 4 b'1011 BRANCH instruction code brnch_mode [22, 21] 2 [0, 4] The conditional branch jumps to the false address when the (brnch_mode && seq_cond_status) == \"00\" brnch_false_addr [20, 15] 6 4 [0, 63] Configures the false address N/A [14, 0] 15 N/A N/A 1100 ROUTE 1101 SRAM_READ 1110 SRAM_WRITE 1111 HALT 5 1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 1 1 1 1 - - - - - - - - - - - - - - - - - - - - - - - Field Position Width Range/Value Description instr_code [26, 23] 4 b'1111 HALT instruction code N/A [22, 0] 23 N/A N/A Example Matlab code 1 2 3 4 5 A = [ 3 : 12 ]; %! RFILE<> [0,0] B = [ 5 : 14 ]; %! RFILE<> [0,0] C = [ 0 ]; %! RFILE<> [0,0] C ( 1 ) = A ( 1 ) + B ( 1 ); %! DPU [0,0] Psudo assembly code (from Vesyla) 1 2 3 4 5 6 7 0 (1 ): SWB , StNo: 3 , Sch:(min: 0 , max: 6 ), 'A_in1_3_00' , S:(REFI<0,0>, PtNo: 3), D:(DPU <0,0>, PtNo: 2) 1 (2 ): SWB , StNo: 3 , Sch:(min: 1 , max: 6 ), 'B_in2_3_00' , S:(REFI<0,0>, PtNo: 2), D:(DPU <0,0>, PtNo: 3) 2 (3 ): SWB , StNo: 3 , Sch:(min: 2 , max: 7 ), 'C_out_3_00' , S:(DPU <0,0>, PtNo: 0), D:(REFI<0,0>, PtNo: 1) 3 (4 ): REFI , StNo: 3 , Sch:(min: 6 , max: 6 ), 'A_in1_3_00' , PortMode: 'in', AddressMode: 'Linear', PortNo: 3, IDelay: 2(S), MDelay: 0(S), RDelay: 0(S), StartAddress: 0(S), StepValue: 0(S), NoOfAddress: 0(S), NoOfRepetition: 0(S), RepOffset: 0 4 (5 ): REFI , StNo: 3 , Sch:(min: 6 , max: 6 ), 'B_in2_3_00' , PortMode: 'in', AddressMode: 'Linear', PortNo: 2, IDelay: 1(S), MDelay: 0(S), RDelay: 0(S), StartAddress: 10(S), StepValue: 0(S), NoOfAddress: 0(S), NoOfRepetition: 0(S), RepOffset: 0 5 (6 ): DPU , StNo: 3 , Sch:(min: 6 , max: 6 ), Mode: 'ADD', ModeValue: 10, ExecutionCycle: 0, Repetition: 0 6 (7 ): REFI , StNo: 3 , Sch:(min: 7 , max: 7 ), 'C_out_3_00' , PortMode: 'out', AddressMode: 'Linear', PortNo: 1, IDelay: 0(S), MDelay: 0(S), RDelay: 0(S), StartAddress: 20(S), StepValue: 0(S), NoOfAddress: 0(S), NoOfRepetition: 0(S), RepOffset: 0 Assembly code (translated) 1 2 3 4 5 6 7 SWB , StNo: 3 , Sch:(min: 0 , max: 6 ), 'A_in1_3_00' , S:(REFI<0,0>, PtNo: 3), D:(DPU <0,0>, PtNo: 2) SWB , StNo: 3 , Sch:(min: 1 , max: 6 ), 'B_in2_3_00' , S:(REFI<0,0>, PtNo: 2), D:(DPU <0,0>, PtNo: 3) SWB , StNo: 3 , Sch:(min: 2 , max: 7 ), 'C_out_3_00' , S:(DPU <0,0>, PtNo: 0), D:(REFI<0,0>, PtNo: 1) REFI1 3, 0, 0, 0, 0, 0, 0, 2 REFI1 2, 0, 0, 10, 0, 0, 0, 1 DPU 10, 0, 0, 0, 0, 0, 0, 0, 0 REFI1 1, 0, 0, 20, 0, 0, 0, 0 Machine code 1 2 3 4 5 6 7 8 9 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | SWB 0 1 0 1 SWB 0 1 0 1 SWB 0 1 0 1 REFI1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 REFI1 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 DPU 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 REFI1 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Saturation : [0]: Integer operation without saturation; [1]: Fixed point without saturation; [2]: Integer operation with saturation; [3]: Fixed point with saturation; \u21a9 Output ports : [0]: Disables both out ports; [1]: Out port 0 will be enabled; [2]: Out port 1 will be enabled; [3]: Both Out port 0 and 1 will be enabled; \u21a9 \u21a9 Process ports : [0]: No preprocessing; [1]: Negates input 0; [2]: Negates input 1; [3]: Absolute of (in0-in1); \u21a9 This number equals to PC size, which is log_2(DEPTH_{instr}) log_2(DEPTH_{instr}) . By default, DEPTH_{instr} = 64 DEPTH_{instr} = 64 . \u21a9 \u21a9 This instruction is not used. \u21a9","title":"Instruction Set"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#instruction-set","text":"","title":"Instruction Set"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#instructions","text":"","title":"Instructions"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0001-refi1","text":"1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 0 0 1 A A B B C D D D D D D E F F F F F F G H H H H Field Position Width Range/Value Description instr_code [26, 23] 4 b'0001 REFI1 instruction code reg_file_port [22, 21] 2 [0, 3] Selects one of the RFile ports subseq_instrs [20, 19] 2 [0, 3] The instruction decoder fetches the consequent (REFI1) or (REFI1 and REFI2) instructions. start_addrs_sd 18 1 [0, 1] The start_addrs is valid only if the start_addrs_sd is 0. Otherwise the start_address would be taken from the RACCU register start_addrs [17, 12] 6 [0, 63] Configures the starting address for the AGU no_of_addrs_sd 11 1 [0, 1] The no_of_addrs is valid only when no_of_addrs_sd is 0, otherwise the no_of_addrs would be taken from the RACCU register. no_of_addrs [10, 5] 6 [0, 63] Configures the number of address for the AGU initial_delay_sd: 4 1 [0, 1] The init_delay is valid only when init_delay_sd is set. initial_delay [3, 0] 4 [0, 15] Configures the initial delay","title":"0001 - REFI1"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0010-refi2","text":"1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 0 1 0 A B B B B B B C D E E E E F G G G G G H H H H Field Position Width Range/Value Description instr_code [26, 23] 4 b'0010 REFI2 instruction code step_val_sd 22 1 [0, 1] The step_val is valid only if step_val_sd is set. step_val [21, 16] 6 [0, 63] Step incremental/decremental value of the address step_val_sign 15 1 [0, 1] If it's 0, address will be incremented by the step_val else decremented by the step_val refi_middle_delay_sd 14 1 [0, 63] The refi_middle_delay is valid only if refi_middle_delay_sd is 0 refi_middle_delay [13, 10] 4 [0, 15] Configures the middle dealy no_of_reps_sd 9 1 [0, 1] The no_of_reps is valid only when the no_of_reps_sd is 0, otherwise the no_of_reps value would be taken from the RACCU register no_of_reps [8, 4] 5 [0, 31] Configures the number of times the address pattern to repeat rpt_step_value [3, 0] 4 [0, 15] The step increment/decrement value","title":"0010 - REFI2"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0011-refi3","text":"","title":"0011 - REFI3"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0100-dpu","text":"1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 1 0 0 A A A A A B B C C D D E F G G G G G G G G H H Field Position Width Range/Value Description instr_code [26, 23] 4 b'0100 DPU instruction code dpu_mode [22, 18] 5 [0, 12] Configures the valid dpu mode dpu_saturation [17, 16] 2 [0, 3] Selects the integer or fixed point operation with or without saturation 1 dpu_output_a [15, 14] 2 [0, 3] Selects one or both the outports 2 dpu_output_b [13, 12] 2 [0, 3] Selects one or both the outports 2 dpu_acc_clear_rst 11 1 [0, 1] Asynchronous reset, when set, clears the DPU accumulator register. dpu_acc_clear_sd 10 1 [0, 1] The dpu_acc_clear is valid only when dpu acc_clear_sd is set. dpu_acc_clear [9, 2] 8 [0, 255] The DPU accumulator register is cleared when the accumulator counter reaches the value configured in the dpu_acc_clear dpu_process_inout [1, 0] 2 [0, 3] Processes the input or output 3","title":"0100 - DPU"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0101-swb","text":"Warning SWB is not a direct mapping instruction. It need to be re-interpret by RTL fabric. Field Position Width Range/Value Description instr_code [26, 23] 4 b'0110 SWB instruction code source_row N/A N/A N/A The source DRRA row source_col [16, 0] 17 N/A The source DRRA column","title":"0101 SWB"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0110-jump","text":"1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 1 1 0 A A A A A A - - - - - - - - - - - - - - - - - Field Position Width Range/Value Description instr_code [26, 23] 4 b'0110 JUMP instruction code true_addrs [22, 17] 6 4 [0, 63] The target address N/A [16, 0] 17 N/A N/A","title":"0110 JUMP"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#0111-delay","text":"1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 1 1 1 A B B B B B B B B B B B B B B B - - - - - - - Field Position Width Range/Value Description instr_code [26, 23] 4 b'0111 DELAY instruction code del_cycles_sd 22 1 [0, 1] The del_cycles is valid only if del_cycles_sd is set del_cycles [21, 7] 15 [0, 32767] Number of clock cycles to wait before decoding the next instruction N/A [6, 0] 7 N/A N/A","title":"0111 DELAY"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1000-for_header","text":"","title":"1000 FOR_HEADER"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1001-for_tail","text":"","title":"1001 FOR_TAIL"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1010-raccu","text":"","title":"1010 RACCU"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1011-branch","text":"1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 0 1 1 1 A A B B B B B B - - - - - - - - - - - - - - - Field Position Width Range/Value Description instr_code [26, 23] 4 b'1011 BRANCH instruction code brnch_mode [22, 21] 2 [0, 4] The conditional branch jumps to the false address when the (brnch_mode && seq_cond_status) == \"00\" brnch_false_addr [20, 15] 6 4 [0, 63] Configures the false address N/A [14, 0] 15 N/A N/A","title":"1011 BRANCH"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1100-route","text":"","title":"1100 ROUTE"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1101-sram_read","text":"","title":"1101 SRAM_READ"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1110-sram_write","text":"","title":"1110 SRAM_WRITE"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#1111-halt5","text":"1 2 3 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | 1 1 1 1 - - - - - - - - - - - - - - - - - - - - - - - Field Position Width Range/Value Description instr_code [26, 23] 4 b'1111 HALT instruction code N/A [22, 0] 23 N/A N/A","title":"1111 HALT5"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#example","text":"","title":"Example"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#matlab-code","text":"1 2 3 4 5 A = [ 3 : 12 ]; %! RFILE<> [0,0] B = [ 5 : 14 ]; %! RFILE<> [0,0] C = [ 0 ]; %! RFILE<> [0,0] C ( 1 ) = A ( 1 ) + B ( 1 ); %! DPU [0,0]","title":"Matlab code"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#psudo-assembly-code-from-vesyla","text":"1 2 3 4 5 6 7 0 (1 ): SWB , StNo: 3 , Sch:(min: 0 , max: 6 ), 'A_in1_3_00' , S:(REFI<0,0>, PtNo: 3), D:(DPU <0,0>, PtNo: 2) 1 (2 ): SWB , StNo: 3 , Sch:(min: 1 , max: 6 ), 'B_in2_3_00' , S:(REFI<0,0>, PtNo: 2), D:(DPU <0,0>, PtNo: 3) 2 (3 ): SWB , StNo: 3 , Sch:(min: 2 , max: 7 ), 'C_out_3_00' , S:(DPU <0,0>, PtNo: 0), D:(REFI<0,0>, PtNo: 1) 3 (4 ): REFI , StNo: 3 , Sch:(min: 6 , max: 6 ), 'A_in1_3_00' , PortMode: 'in', AddressMode: 'Linear', PortNo: 3, IDelay: 2(S), MDelay: 0(S), RDelay: 0(S), StartAddress: 0(S), StepValue: 0(S), NoOfAddress: 0(S), NoOfRepetition: 0(S), RepOffset: 0 4 (5 ): REFI , StNo: 3 , Sch:(min: 6 , max: 6 ), 'B_in2_3_00' , PortMode: 'in', AddressMode: 'Linear', PortNo: 2, IDelay: 1(S), MDelay: 0(S), RDelay: 0(S), StartAddress: 10(S), StepValue: 0(S), NoOfAddress: 0(S), NoOfRepetition: 0(S), RepOffset: 0 5 (6 ): DPU , StNo: 3 , Sch:(min: 6 , max: 6 ), Mode: 'ADD', ModeValue: 10, ExecutionCycle: 0, Repetition: 0 6 (7 ): REFI , StNo: 3 , Sch:(min: 7 , max: 7 ), 'C_out_3_00' , PortMode: 'out', AddressMode: 'Linear', PortNo: 1, IDelay: 0(S), MDelay: 0(S), RDelay: 0(S), StartAddress: 20(S), StepValue: 0(S), NoOfAddress: 0(S), NoOfRepetition: 0(S), RepOffset: 0","title":"Psudo assembly code (from Vesyla)"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#assembly-code-translated","text":"1 2 3 4 5 6 7 SWB , StNo: 3 , Sch:(min: 0 , max: 6 ), 'A_in1_3_00' , S:(REFI<0,0>, PtNo: 3), D:(DPU <0,0>, PtNo: 2) SWB , StNo: 3 , Sch:(min: 1 , max: 6 ), 'B_in2_3_00' , S:(REFI<0,0>, PtNo: 2), D:(DPU <0,0>, PtNo: 3) SWB , StNo: 3 , Sch:(min: 2 , max: 7 ), 'C_out_3_00' , S:(DPU <0,0>, PtNo: 0), D:(REFI<0,0>, PtNo: 1) REFI1 3, 0, 0, 0, 0, 0, 0, 2 REFI1 2, 0, 0, 10, 0, 0, 0, 1 DPU 10, 0, 0, 0, 0, 0, 0, 0, 0 REFI1 1, 0, 0, 20, 0, 0, 0, 0","title":"Assembly code (translated)"},{"location":"Docs/ToolChain/Vesyla/Instruction-Set/#machine-code","text":"1 2 3 4 5 6 7 8 9 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00 | | | | | | | | | | | | | | | | | | | | | | | | | | | SWB 0 1 0 1 SWB 0 1 0 1 SWB 0 1 0 1 REFI1 0 0 0 1 1 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 REFI1 0 0 0 1 1 0 0 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 DPU 0 1 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 REFI1 0 0 0 1 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 Saturation : [0]: Integer operation without saturation; [1]: Fixed point without saturation; [2]: Integer operation with saturation; [3]: Fixed point with saturation; \u21a9 Output ports : [0]: Disables both out ports; [1]: Out port 0 will be enabled; [2]: Out port 1 will be enabled; [3]: Both Out port 0 and 1 will be enabled; \u21a9 \u21a9 Process ports : [0]: No preprocessing; [1]: Negates input 0; [2]: Negates input 1; [3]: Absolute of (in0-in1); \u21a9 This number equals to PC size, which is log_2(DEPTH_{instr}) log_2(DEPTH_{instr}) . By default, DEPTH_{instr} = 64 DEPTH_{instr} = 64 . \u21a9 \u21a9 This instruction is not used. \u21a9","title":"Machine code"},{"location":"Docs/ToolChain/Vesyla/Overview/","text":"Warning Documentation is not complete!","title":"Overview"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/","text":"Programming Guide Basics General Guide Vesyla accept modified matlab code as input language. You shouldn't write the matlab code like a programming language. You should instead use it as a tool to model the behaviour of the hardware. Vesyla supports small portion of matlab grammar. There are some generic rules expressing the programming style vesyla accepts. General function call is not allowed unless the function is predefined as primitive function. Variable except for constant variable and loop iterator should always be decleared via pragma. Statement should always ends with semicolon ( ; ) to avoid unexpected outputs while simulating in matlab. Constant number is normally treated as integers, not double floating point. Pragma Pragma is the notation that guides Vesyla during synthesis process. Vesyla recongnize pragma starting with symbols %! . The main function of pragmas is specify allocation and binding information since Vesyla can't perform automatic allocation and binding. Section Variable Declaration , Arithmetic Operation , Address Constraint DPU Chain and DPU Internal Scalar Register describe how to use pragmas to allocate and bind resources. Some other usage of pragma also exist, check section Resource Sharing Region for more detail. Variable Declaration Variables supported by Vesyla are vectored Register file variables and SRAM variables. Register file variables will bind to register file and SRAM variables will bind to DiMArch. Since matlab dosen't require variable declaration, we need to give initial value to declare them. You can use the standard initialization assignment for matlab 1-D arry to declare a variable. Function such as zeros() and ones() are also supported. To declear SRAM variable, you need to use %! MEM[row, col] pragma. row and col are the coordinate of the SRAM block you want to bind for this variable. SRAM usually organized as a 2-D bit matrix without bit-level and word-level access. Data communication with SRAM happens in bulk mode where each data exchange need to be a complete SRAM row. Suppose SRAM with is N N and Register width (1 word) is M M bit. Each SRAM row will have N/M N/M words. Typical value for M M and N N are M=256 M=256 and N=16 N=16 . Since SRAM only support whole line reading and writing, the SRAM variable you defined should always have multiple of M/N M/N elements. Example The example shows how to define a SRAM variable y on SRAM block [0,0] . y is initialized by a 1-D vector [1,2,3,4,5,...,16] . 1 y = [ 1 : 16 ]; %! MEM[0,0] To declear register file variable, you need to use %! RFIL[row, col] pragma. row and col are the coordinate of the DRRA cell you want to bind for this variable. Unlike SRAM, register file is organized in the way that each row will always represent a word. So there is no restriction on the size of register file variable as long as it doesn't exceed the register depth limit. Example The example shows how to define a register file variable x on DRRA cell [0,0] . x has 5 elements and is initialized by a zeros() function which will set all elements in x to 0 . 1 x = zeros ( 1 , 5 ); %! REFI[0,0] For debugging purpose, vesyla allows initialization of register file variable. However, register should not be initialized with any value other than zeros because the real DRRA cell doesn't have interface to support the register initalization. Register file variables hence should always get data from SRAM variables. Error The following variable declaration style is incorrect: No storage pragma specified 1 x = zeros ( 1 , 5 ); Initialized to scalar 1 x = 1 ; %! RFILE[1,1] Initialized to 2-D array 1 x = ones ( 2 , 3 ); %! RFILE[1,1] SRAM varible is not the size of SRAM row 1 x = [ 1 : 3 ]; %! MEM[0,1] Initialization function randi() is not supported 1 x = randi ( 10 , 1 , 16 ); %! MEM[0,1] Vector Slicing and Address Generation Each DPU can only process one scalar data each time, so the vectored register variable should be slice first before sending to DPU. The slicing operation is mapped on AGU by REFI instruction. While writing matlab code, you don't have to worry about the slicing since matlab directly support vector slicing. Here is an example of slicing a vector: Example 1 2 3 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] y ( 1 : 5 ) = x ( 1 : 5 ) + y ( 1 : 5 ); %! DPU[0,0] If you don't use any slicing and directly feed a vectored register variable to arithmetic operaion, Vesyla will use the full range of that variable. When slicing a SRAM varialbe, the minimal slice should always be multiple of 16. Except for the matlab default slicing method, you can also use two primitive AGU function to linear slice a vectored varialbe both in 1-D or 2-D. Example is given below. All address sequence in the following example are \"1,2,3,4,5\". Example 1 2 3 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] y ( 1 : 5 ) = x ( silago_agu_linear_1d ( 1 , 1 , 5 )) + y ( silago_agu_linear_2d ( 1 , 0 , 1 , 1 , 5 )); %! DPU[0,0] Arithmetic Operation Certain type of arithmetic operations are supported by Vesyla. They are addition, subtraction, dot multiplication, sum, abs, etc. Special arithmetic operation need to be mapped to special DPU mode by primitive function call, see section Primitive Function . Bug Symbol ~ is not supported yet! For arithmetic assignment, you can have a multiple variables as output depending on the DPU mode. The ignored output can be muted by symbol ~ . Arithmetic operation need a computation resource to perform required operation, that is the DPU. So, every arithmetic operation need to bind to a DPU resource via pragma. Example of an arithmetic assignment is demonstrated as following: Example 1 2 3 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] y ( 1 : 5 ) = x ( 1 : 5 ) + y ( 1 : 5 ); %! DPU[0,0] Static Loop Vesyla accept all static loops. A static loop should have constant start point, static increment as well as static iteration. If an expression that can be simplified to a constant number, it also considered as constant, hence can be used in static loop. Example below shows how to use a static loop. Example 1 2 3 4 n = 3 ; for i = 1:1:n+1 ... end Dynamic Loop Vesyla support limited dynamic loops. Dynamic loop can have dynamic start point, and dynamic iteration. However, those number should be in address domain, a.k.a computed by RACCU and is fully determinastic after unrolling all the loops. Example of such dynamic loop is shown below: Example 1 2 3 4 5 for i = 1 : 1 : 4 for j = i:1:i+3 ... end end Branch Vesyla support normal matlab branch except for both operands of condition are constants. The usage of branch is the same as the original matlab code. For example: Example 1 2 3 4 5 6 7 8 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] w = [ 3 , 5 ]; %! REFI[0,0] if w ( 1 ) > w ( 2 ) y = x ; else y = x+y ; %! DPU[0,0] end Address Constraint Address constraints are parameters used by address generation in AGU. Address constraints can be constant or RACCU variable calculated at run-time in RACCU. Dynamic address constraint variables are usually used in loops. Example below shows how to use a RACCU variable to serve as address constraint. Example 1 2 3 4 5 6 7 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 16 ]; %! REFI[0,0] a = 1 ; %! RACCU_VAR for i = 1 : 1 : 4 y ( a + 1 : a + 1 + 5 ) = x ( 1 : 5 ) + y ( a : a + 5 ); %! DPU[0,0] a = a + 1 ; end Advanced Features Macro Vesyla support symbolic expression to enable fast design space exploration. One of the technique is to use macros. Before the lexecal analysis, vesyla will expand all macro to normal program code. Macro gives programmer the tool to generate multiple program with small variations. Programmer need to provide a template and a series of data. Data is organized in json format and will be loaded in to evaluate those macros defined in template. Template use a grammar like the templating package inja . Infact, vesyla directly use inja library to evaluate macros. Example below demonstrate how to define a loop in template: Example An template file defined as following: 1 2 3 4 { % for x in range(par_col) %} x0_mem_ {{ x }} = [ 1 : n / col ]; %! MEM[0, {{x}}] y0_mem_ {{ x }} = [ 1 : n / col ]; %! MEM[0, {{x}}] { % endfor %} With a json-formated data file: 1 { \"par_col\" : 2 } This template will generate a real matlab code as following by expanding the FOR-LOOP macro: 1 2 3 4 x0_mem_0 = [ 1 : n / col ]; %! MEM[0, 0] y0_mem_0 = [ 1 : n / col ]; %! MEM[0, 0] x0_mem_1 = [ 1 : n / col ]; %! MEM[0, 1] y0_mem_1 = [ 1 : n / col ]; %! MEM[0, 1] Tip More complex usage please visit inja website. Primitive Function Primitive DPU functions are functions that corresponds to a complete DPU mode. Different DPUs targeting on different application domain may have some special modes specifically made for such application domain. For example, sigmoid function for neural network application. Those primitive function is not directly supported by matlab, but they are supported by vesyla. To use a specific DPU mode as primitive function, first you need to make sure the DRRA cell you are using has such mode. Then you need to change the configuration of vesyla to recongnize such mode. The configuration file is $Vesyla_root/config/primitive_func_def.xml . Finally, you can use the function inside your program. All primitive DPU functions have name should start with silago_dpu_ to be accepted by Vesyla. Example of using primitive DPU function: Example 1 2 x = [ 1 : 5 ]; %! REFI[0,0] x = silago_dpu_sigmoid ( x ); %! DPU[0,0] AUGs also have special primitive functions to express the complex addressing mode. But AGU primitive functions are not custom. There are two AGU primitive function: silago_agu_linear_1d() and silago_agu_linear_2d() . More AGU primitive functions will be added if some application domain requires. Example of using primitive DPU function: Example 1 2 3 x = [ 1 : 5 ]; %! REFI[0,0] a = [ 1 ]; %! REFI[0,0] x = x + a ( silago_agu_linear_1d ( 1 , 0 , 5 )); %! DPU[0,0] Resource Sharing Region When multiple operations need some common operands, due to the limit of the number of reading ports, those operations can't happen at the same time in normal condition. Resource sharing region tries to solve the problem. By enabling the broadcasting mechanism, all operation will recieve the same common operand at the same time generated by single reading port of the register file. The datapath of transmitting the common operand is now shared among those operations. Resource sharing region requires a fixed datapath layout. Dynamic change of datapath structure is forbidden inside resource sharing region. So, you should only use it when needed. Following example shows how to active resource sharing region. Example 1 2 3 4 5 6 7 8 9 10 11 12 x0 = [ 1 : 5 ]; %! REFI[0,0] x1 = [ 1 : 5 ]; %! REFI[1,0] a2 = [ 1 : 5 ]; %! REFI[2,0] x3 = [ 1 : 5 ]; %! REFI[3,0] x4 = [ 1 : 5 ]; %! REFI[4,0] %! RESOURCE_SHARING_BEGIN x0 = x0 + a2 ; %! DPU[0,0] x1 = x1 + a2 ; %! DPU[1,0] x3 = x3 + a2 ; %! DPU[3,0] x4 = x4 + a2 ; %! DPU[4,0] %! RESOURCE_SHARING_END DPU Chain Datapath can be configured as a chain of DPU operation. The output of the previous DPU will immediately enter the next DPU without any register file involved in between. Consider we want to compute a vector addition and a sigmoid function: z = \\sigma (x+y) z = \\sigma (x+y) . We can employ two DPUs to perform the complete operation in pipelined fashion. By writing the matlab like the following, you can enable the feature. Example 1 2 3 4 5 6 7 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] z = [ 1 : 5 ]; %! REFI[0,0] t = zeros ( 1 , 5 ); %! CDPU[0,0] t = x + y ; z = silago_dpu_sigmoid ( t ); %! DPU[1,0] DPU Internal Scalar Register Inside each DPU, there are two internal scalar registers which can be explicitly used via high-level matlab program. One can use them by declearing them with the pragma %! CDPU[row, col] . The available functions to load and store values to/from internal scalar registers are: 1 2 3 4 5 6 r0 = silago_dpu_load_reg_0 ( x ( 1 )); r1 = silago_dpu_load_reg_1 ( x ( 1 )); [ r0 , r1 ] = silago_dpu_load_reg_both ( x ( 1 ), x ( 2 )); x ( 1 ) = silago_dpu_load_store_0 ( r0 ); x ( 1 ) = silago_dpu_load_store_1 ( r1 ); [ x ( 1 ), y ( 1 )] = silago_dpu_load_store_both ( r0 , r1 ); Warning Programmer should keep in mind that lifetime and physical location of those variable. Vesyla has very weak semantic checking on those internal scalar register variables. Example For example, if one want to calculate a function: y = ax.y y = ax.y . Instead of put the coefficient a a inside a normal register and waste other register entries of the same register block, you can put the coefficient to the internal register, and configure DPU to a scaled multiplication mode to get the correct result. 1 2 3 4 5 6 7 8 9 10 11 12 13 a_mem = [ 1 : 16 ]; %! SRAM[0,0] x_mem = [ 1 : 16 ]; %! SRAM[0,0] y_mem = [ 1 : 16 ]; %! SRAM[0,0] x = [ 1 : 16 ]; %! REFI[0,0] y = [ 1 : 16 ]; %! REFI[0,0] r = zeros ( 1 , 1 ); %! CDPU[0,0] x = a_mem ; r = silago_dpu_load_reg_1 ( x ( 1 )); x = x_mem ; y = y_mem ; y = silago_dpu_scaled_mul ( x , y , r ); %! DPU[0,0] y_mem = y ; Not Supported Some matlab code is not accepted by Vesyla because it can't execute on DRRA fabric. They are: While-loop. For-loop inside branch. Arithmetic statement that can't be mapped to single DPU mode. Normal function call except for primitive function call. Indirect addressing.","title":"Programming Guide"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#programming-guide","text":"","title":"Programming Guide"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#basics","text":"","title":"Basics"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#general-guide","text":"Vesyla accept modified matlab code as input language. You shouldn't write the matlab code like a programming language. You should instead use it as a tool to model the behaviour of the hardware. Vesyla supports small portion of matlab grammar. There are some generic rules expressing the programming style vesyla accepts. General function call is not allowed unless the function is predefined as primitive function. Variable except for constant variable and loop iterator should always be decleared via pragma. Statement should always ends with semicolon ( ; ) to avoid unexpected outputs while simulating in matlab. Constant number is normally treated as integers, not double floating point.","title":"General Guide"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#pragma","text":"Pragma is the notation that guides Vesyla during synthesis process. Vesyla recongnize pragma starting with symbols %! . The main function of pragmas is specify allocation and binding information since Vesyla can't perform automatic allocation and binding. Section Variable Declaration , Arithmetic Operation , Address Constraint DPU Chain and DPU Internal Scalar Register describe how to use pragmas to allocate and bind resources. Some other usage of pragma also exist, check section Resource Sharing Region for more detail.","title":"Pragma"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#variable-declaration","text":"Variables supported by Vesyla are vectored Register file variables and SRAM variables. Register file variables will bind to register file and SRAM variables will bind to DiMArch. Since matlab dosen't require variable declaration, we need to give initial value to declare them. You can use the standard initialization assignment for matlab 1-D arry to declare a variable. Function such as zeros() and ones() are also supported. To declear SRAM variable, you need to use %! MEM[row, col] pragma. row and col are the coordinate of the SRAM block you want to bind for this variable. SRAM usually organized as a 2-D bit matrix without bit-level and word-level access. Data communication with SRAM happens in bulk mode where each data exchange need to be a complete SRAM row. Suppose SRAM with is N N and Register width (1 word) is M M bit. Each SRAM row will have N/M N/M words. Typical value for M M and N N are M=256 M=256 and N=16 N=16 . Since SRAM only support whole line reading and writing, the SRAM variable you defined should always have multiple of M/N M/N elements. Example The example shows how to define a SRAM variable y on SRAM block [0,0] . y is initialized by a 1-D vector [1,2,3,4,5,...,16] . 1 y = [ 1 : 16 ]; %! MEM[0,0] To declear register file variable, you need to use %! RFIL[row, col] pragma. row and col are the coordinate of the DRRA cell you want to bind for this variable. Unlike SRAM, register file is organized in the way that each row will always represent a word. So there is no restriction on the size of register file variable as long as it doesn't exceed the register depth limit. Example The example shows how to define a register file variable x on DRRA cell [0,0] . x has 5 elements and is initialized by a zeros() function which will set all elements in x to 0 . 1 x = zeros ( 1 , 5 ); %! REFI[0,0] For debugging purpose, vesyla allows initialization of register file variable. However, register should not be initialized with any value other than zeros because the real DRRA cell doesn't have interface to support the register initalization. Register file variables hence should always get data from SRAM variables. Error The following variable declaration style is incorrect: No storage pragma specified 1 x = zeros ( 1 , 5 ); Initialized to scalar 1 x = 1 ; %! RFILE[1,1] Initialized to 2-D array 1 x = ones ( 2 , 3 ); %! RFILE[1,1] SRAM varible is not the size of SRAM row 1 x = [ 1 : 3 ]; %! MEM[0,1] Initialization function randi() is not supported 1 x = randi ( 10 , 1 , 16 ); %! MEM[0,1]","title":"Variable Declaration"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#vector-slicing-and-address-generation","text":"Each DPU can only process one scalar data each time, so the vectored register variable should be slice first before sending to DPU. The slicing operation is mapped on AGU by REFI instruction. While writing matlab code, you don't have to worry about the slicing since matlab directly support vector slicing. Here is an example of slicing a vector: Example 1 2 3 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] y ( 1 : 5 ) = x ( 1 : 5 ) + y ( 1 : 5 ); %! DPU[0,0] If you don't use any slicing and directly feed a vectored register variable to arithmetic operaion, Vesyla will use the full range of that variable. When slicing a SRAM varialbe, the minimal slice should always be multiple of 16. Except for the matlab default slicing method, you can also use two primitive AGU function to linear slice a vectored varialbe both in 1-D or 2-D. Example is given below. All address sequence in the following example are \"1,2,3,4,5\". Example 1 2 3 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] y ( 1 : 5 ) = x ( silago_agu_linear_1d ( 1 , 1 , 5 )) + y ( silago_agu_linear_2d ( 1 , 0 , 1 , 1 , 5 )); %! DPU[0,0]","title":"Vector Slicing and Address Generation"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#arithmetic-operation","text":"Certain type of arithmetic operations are supported by Vesyla. They are addition, subtraction, dot multiplication, sum, abs, etc. Special arithmetic operation need to be mapped to special DPU mode by primitive function call, see section Primitive Function . Bug Symbol ~ is not supported yet! For arithmetic assignment, you can have a multiple variables as output depending on the DPU mode. The ignored output can be muted by symbol ~ . Arithmetic operation need a computation resource to perform required operation, that is the DPU. So, every arithmetic operation need to bind to a DPU resource via pragma. Example of an arithmetic assignment is demonstrated as following: Example 1 2 3 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] y ( 1 : 5 ) = x ( 1 : 5 ) + y ( 1 : 5 ); %! DPU[0,0]","title":"Arithmetic Operation"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#static-loop","text":"Vesyla accept all static loops. A static loop should have constant start point, static increment as well as static iteration. If an expression that can be simplified to a constant number, it also considered as constant, hence can be used in static loop. Example below shows how to use a static loop. Example 1 2 3 4 n = 3 ; for i = 1:1:n+1 ... end","title":"Static Loop"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#dynamic-loop","text":"Vesyla support limited dynamic loops. Dynamic loop can have dynamic start point, and dynamic iteration. However, those number should be in address domain, a.k.a computed by RACCU and is fully determinastic after unrolling all the loops. Example of such dynamic loop is shown below: Example 1 2 3 4 5 for i = 1 : 1 : 4 for j = i:1:i+3 ... end end","title":"Dynamic Loop"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#branch","text":"Vesyla support normal matlab branch except for both operands of condition are constants. The usage of branch is the same as the original matlab code. For example: Example 1 2 3 4 5 6 7 8 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] w = [ 3 , 5 ]; %! REFI[0,0] if w ( 1 ) > w ( 2 ) y = x ; else y = x+y ; %! DPU[0,0] end","title":"Branch"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#address-constraint","text":"Address constraints are parameters used by address generation in AGU. Address constraints can be constant or RACCU variable calculated at run-time in RACCU. Dynamic address constraint variables are usually used in loops. Example below shows how to use a RACCU variable to serve as address constraint. Example 1 2 3 4 5 6 7 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 16 ]; %! REFI[0,0] a = 1 ; %! RACCU_VAR for i = 1 : 1 : 4 y ( a + 1 : a + 1 + 5 ) = x ( 1 : 5 ) + y ( a : a + 5 ); %! DPU[0,0] a = a + 1 ; end","title":"Address Constraint"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#advanced-features","text":"","title":"Advanced Features"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#macro","text":"Vesyla support symbolic expression to enable fast design space exploration. One of the technique is to use macros. Before the lexecal analysis, vesyla will expand all macro to normal program code. Macro gives programmer the tool to generate multiple program with small variations. Programmer need to provide a template and a series of data. Data is organized in json format and will be loaded in to evaluate those macros defined in template. Template use a grammar like the templating package inja . Infact, vesyla directly use inja library to evaluate macros. Example below demonstrate how to define a loop in template: Example An template file defined as following: 1 2 3 4 { % for x in range(par_col) %} x0_mem_ {{ x }} = [ 1 : n / col ]; %! MEM[0, {{x}}] y0_mem_ {{ x }} = [ 1 : n / col ]; %! MEM[0, {{x}}] { % endfor %} With a json-formated data file: 1 { \"par_col\" : 2 } This template will generate a real matlab code as following by expanding the FOR-LOOP macro: 1 2 3 4 x0_mem_0 = [ 1 : n / col ]; %! MEM[0, 0] y0_mem_0 = [ 1 : n / col ]; %! MEM[0, 0] x0_mem_1 = [ 1 : n / col ]; %! MEM[0, 1] y0_mem_1 = [ 1 : n / col ]; %! MEM[0, 1] Tip More complex usage please visit inja website.","title":"Macro"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#primitive-function","text":"Primitive DPU functions are functions that corresponds to a complete DPU mode. Different DPUs targeting on different application domain may have some special modes specifically made for such application domain. For example, sigmoid function for neural network application. Those primitive function is not directly supported by matlab, but they are supported by vesyla. To use a specific DPU mode as primitive function, first you need to make sure the DRRA cell you are using has such mode. Then you need to change the configuration of vesyla to recongnize such mode. The configuration file is $Vesyla_root/config/primitive_func_def.xml . Finally, you can use the function inside your program. All primitive DPU functions have name should start with silago_dpu_ to be accepted by Vesyla. Example of using primitive DPU function: Example 1 2 x = [ 1 : 5 ]; %! REFI[0,0] x = silago_dpu_sigmoid ( x ); %! DPU[0,0] AUGs also have special primitive functions to express the complex addressing mode. But AGU primitive functions are not custom. There are two AGU primitive function: silago_agu_linear_1d() and silago_agu_linear_2d() . More AGU primitive functions will be added if some application domain requires. Example of using primitive DPU function: Example 1 2 3 x = [ 1 : 5 ]; %! REFI[0,0] a = [ 1 ]; %! REFI[0,0] x = x + a ( silago_agu_linear_1d ( 1 , 0 , 5 )); %! DPU[0,0]","title":"Primitive Function"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#resource-sharing-region","text":"When multiple operations need some common operands, due to the limit of the number of reading ports, those operations can't happen at the same time in normal condition. Resource sharing region tries to solve the problem. By enabling the broadcasting mechanism, all operation will recieve the same common operand at the same time generated by single reading port of the register file. The datapath of transmitting the common operand is now shared among those operations. Resource sharing region requires a fixed datapath layout. Dynamic change of datapath structure is forbidden inside resource sharing region. So, you should only use it when needed. Following example shows how to active resource sharing region. Example 1 2 3 4 5 6 7 8 9 10 11 12 x0 = [ 1 : 5 ]; %! REFI[0,0] x1 = [ 1 : 5 ]; %! REFI[1,0] a2 = [ 1 : 5 ]; %! REFI[2,0] x3 = [ 1 : 5 ]; %! REFI[3,0] x4 = [ 1 : 5 ]; %! REFI[4,0] %! RESOURCE_SHARING_BEGIN x0 = x0 + a2 ; %! DPU[0,0] x1 = x1 + a2 ; %! DPU[1,0] x3 = x3 + a2 ; %! DPU[3,0] x4 = x4 + a2 ; %! DPU[4,0] %! RESOURCE_SHARING_END","title":"Resource Sharing Region"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#dpu-chain","text":"Datapath can be configured as a chain of DPU operation. The output of the previous DPU will immediately enter the next DPU without any register file involved in between. Consider we want to compute a vector addition and a sigmoid function: z = \\sigma (x+y) z = \\sigma (x+y) . We can employ two DPUs to perform the complete operation in pipelined fashion. By writing the matlab like the following, you can enable the feature. Example 1 2 3 4 5 6 7 x = [ 1 : 5 ]; %! REFI[0,0] y = [ 1 : 5 ]; %! REFI[0,0] z = [ 1 : 5 ]; %! REFI[0,0] t = zeros ( 1 , 5 ); %! CDPU[0,0] t = x + y ; z = silago_dpu_sigmoid ( t ); %! DPU[1,0]","title":"DPU Chain"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#dpu-internal-scalar-register","text":"Inside each DPU, there are two internal scalar registers which can be explicitly used via high-level matlab program. One can use them by declearing them with the pragma %! CDPU[row, col] . The available functions to load and store values to/from internal scalar registers are: 1 2 3 4 5 6 r0 = silago_dpu_load_reg_0 ( x ( 1 )); r1 = silago_dpu_load_reg_1 ( x ( 1 )); [ r0 , r1 ] = silago_dpu_load_reg_both ( x ( 1 ), x ( 2 )); x ( 1 ) = silago_dpu_load_store_0 ( r0 ); x ( 1 ) = silago_dpu_load_store_1 ( r1 ); [ x ( 1 ), y ( 1 )] = silago_dpu_load_store_both ( r0 , r1 ); Warning Programmer should keep in mind that lifetime and physical location of those variable. Vesyla has very weak semantic checking on those internal scalar register variables. Example For example, if one want to calculate a function: y = ax.y y = ax.y . Instead of put the coefficient a a inside a normal register and waste other register entries of the same register block, you can put the coefficient to the internal register, and configure DPU to a scaled multiplication mode to get the correct result. 1 2 3 4 5 6 7 8 9 10 11 12 13 a_mem = [ 1 : 16 ]; %! SRAM[0,0] x_mem = [ 1 : 16 ]; %! SRAM[0,0] y_mem = [ 1 : 16 ]; %! SRAM[0,0] x = [ 1 : 16 ]; %! REFI[0,0] y = [ 1 : 16 ]; %! REFI[0,0] r = zeros ( 1 , 1 ); %! CDPU[0,0] x = a_mem ; r = silago_dpu_load_reg_1 ( x ( 1 )); x = x_mem ; y = y_mem ; y = silago_dpu_scaled_mul ( x , y , r ); %! DPU[0,0] y_mem = y ;","title":"DPU Internal Scalar Register"},{"location":"Docs/ToolChain/Vesyla/ProgrammingGuide/#not-supported","text":"Some matlab code is not accepted by Vesyla because it can't execute on DRRA fabric. They are: While-loop. For-loop inside branch. Arithmetic statement that can't be mapped to single DPU mode. Normal function call except for primitive function call. Indirect addressing.","title":"Not Supported"},{"location":"Docs/ToolChain/Vesyla/Scheduling/","text":"Error : [Errno 2] No such file or directory: 'dot': 'dot' : ['dot', '-Tpng'] digraph G { rankdir=\"LR\"; u -> v [label=\"[1, 5]\"]; u -> w [label=\"[1, 2]\"]; w -> v [label=\"[0, 1]\"]; }","title":"Scheduling"},{"location":"Docs/ToolChain/Vesyla/Tutorial/","text":"Vesyla tutorial Working environment OS : Linux Software : Matlab QuestaSim File structure 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $VesylaRoot/ |- src/ | |- all source files. | |- matlab_lib/ | |- matlab behavior models for DPU modes | |- config/ | |- some configuration files. | |- autotest/ | |- some scripts for auto testing. | |- some testcases. | |- build/ |- compilation working directory Compile Vesyla First, install compilation tool chain. You need to use the correct package manager of your Linux distribution. The needed packages include: g++ (version 5 or above), make, cmake, boost liabrires, gecode. Here, we give the example command for Fedora Linux. 1 sudo yum install g ++ make cmake boost-devel Gecode is not really necessary, Vesyla only use it for CP scheduling engine. However, you still need to install it. You can install it according to the installation instruction on the official website: https://www.gecode.org/ Then, you create working directory build . 1 2 3 cd $VesylaRoot mkdir build cd build Next step is to generate makefile according to the CMake configuration file CMakeLists.txt. 1 cmake .. Now, it's time to compile vesyla. 1 make After a while, the executable file named as \"vesyla\" should appear in the build directory. Write the source code Please Check the Programming Guide . Compilation and simulation Use automatic test framework Warning Not available in public github repo A bash script called $VesylaRoot/autotest/testall.sh is provided to automatically test many testcases. Put all your testcases (matlab file) in $VesylaRoot/autotest/testcases/ directory, the script will test all of them and generate a report in the same directory. The script uses Robot Framework to manage the test process and to generate result. To run the test script, use command: 1 . / testall Use automatic test script to test single testcase Script using test framework can test many testcases, but it will not print out detailed information. If you want to test single testcases, there is a provided bash script. It automatically compile your matlab file, prepare simulation environment and perform the matlab and RTL simulation, and finally compare the result. The script is called $VesylaRoot/autotest/run.sh . To use it, use the command below: 1 . / run - c - f $PathToSiLagoFabric $PathToYourMatlabFile -c parameter try to compile Vesyla everytime in case Vesyla is modified, -f $PathToSiLagoFabric parameter indicates the RTL description of the SiLago fabric used for RTL simulation. After the script has been executed, a message SUCCESS or FAIL will show at the end to report whether the source file is correct or not. Manually testing Compile testcase To compile a testcase that is purely matlab script by using Vesyla, go to the build directory and run: 1 . / vesyla - o $PathToOutputDirectory $PathToMatlabFile If instead, you want to compile a testcase that consists a template file and a data file, go to the build directory and run: 1 . / vesyla - o $PathToOutputDirectory $PathToTemplate $PathToData Matlab simulation Vesyla generates a matlab simulation environment inside the output directory specified when you compile the testcase. Suppose your output directory is $OUTPUT , the matlab simulation environment is in $OUTPUT/filegen/sim_matlab . You can simulate the matlab model named as instrumenteed_code.m in matlab and get the register file data change event recording from the generated files after simulation. QuestaSim simulation Vesyla also generates environment for RTL simulation. It's in $OUTPUT/filegen/sim_vsim . However, you can't directly simulate it under QuestaSim because you need to specify the path to the DRRA+DiMArch fabric. You need to change the automatic script according to the actual fabric RTL location in order to make the simulation work. Please check the provided automatic test script $ROOT/autotest/run.sh to know more about how to add the fabric information. After QuestaSim simulation, a register file data change event recording will also be generated. Compare the register file data change A way to verify the correct behaviour of vesyla is to compare the register file data change event recording generated from both matlab and RTL simulation. A program for the exact purpose is created while vesyla is compiled. To run the program, go to build directory and use command: 1 . / vesyla_verify $PathToMatlabRecording $PathToVsimRecording Important output files Warning Update later.","title":"Vesyla tutorial"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#vesyla-tutorial","text":"","title":"Vesyla tutorial"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#working-environment","text":"OS : Linux Software : Matlab QuestaSim","title":"Working environment"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#file-structure","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 $VesylaRoot/ |- src/ | |- all source files. | |- matlab_lib/ | |- matlab behavior models for DPU modes | |- config/ | |- some configuration files. | |- autotest/ | |- some scripts for auto testing. | |- some testcases. | |- build/ |- compilation working directory","title":"File structure"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#compile-vesyla","text":"First, install compilation tool chain. You need to use the correct package manager of your Linux distribution. The needed packages include: g++ (version 5 or above), make, cmake, boost liabrires, gecode. Here, we give the example command for Fedora Linux. 1 sudo yum install g ++ make cmake boost-devel Gecode is not really necessary, Vesyla only use it for CP scheduling engine. However, you still need to install it. You can install it according to the installation instruction on the official website: https://www.gecode.org/ Then, you create working directory build . 1 2 3 cd $VesylaRoot mkdir build cd build Next step is to generate makefile according to the CMake configuration file CMakeLists.txt. 1 cmake .. Now, it's time to compile vesyla. 1 make After a while, the executable file named as \"vesyla\" should appear in the build directory.","title":"Compile Vesyla"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#write-the-source-code","text":"Please Check the Programming Guide .","title":"Write the source code"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#compilation-and-simulation","text":"","title":"Compilation and simulation"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#use-automatic-test-framework","text":"Warning Not available in public github repo A bash script called $VesylaRoot/autotest/testall.sh is provided to automatically test many testcases. Put all your testcases (matlab file) in $VesylaRoot/autotest/testcases/ directory, the script will test all of them and generate a report in the same directory. The script uses Robot Framework to manage the test process and to generate result. To run the test script, use command: 1 . / testall","title":"Use automatic test framework"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#use-automatic-test-script-to-test-single-testcase","text":"Script using test framework can test many testcases, but it will not print out detailed information. If you want to test single testcases, there is a provided bash script. It automatically compile your matlab file, prepare simulation environment and perform the matlab and RTL simulation, and finally compare the result. The script is called $VesylaRoot/autotest/run.sh . To use it, use the command below: 1 . / run - c - f $PathToSiLagoFabric $PathToYourMatlabFile -c parameter try to compile Vesyla everytime in case Vesyla is modified, -f $PathToSiLagoFabric parameter indicates the RTL description of the SiLago fabric used for RTL simulation. After the script has been executed, a message SUCCESS or FAIL will show at the end to report whether the source file is correct or not.","title":"Use automatic test script to test single testcase"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#manually-testing","text":"","title":"Manually testing"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#compile-testcase","text":"To compile a testcase that is purely matlab script by using Vesyla, go to the build directory and run: 1 . / vesyla - o $PathToOutputDirectory $PathToMatlabFile If instead, you want to compile a testcase that consists a template file and a data file, go to the build directory and run: 1 . / vesyla - o $PathToOutputDirectory $PathToTemplate $PathToData","title":"Compile testcase"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#matlab-simulation","text":"Vesyla generates a matlab simulation environment inside the output directory specified when you compile the testcase. Suppose your output directory is $OUTPUT , the matlab simulation environment is in $OUTPUT/filegen/sim_matlab . You can simulate the matlab model named as instrumenteed_code.m in matlab and get the register file data change event recording from the generated files after simulation.","title":"Matlab simulation"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#questasim-simulation","text":"Vesyla also generates environment for RTL simulation. It's in $OUTPUT/filegen/sim_vsim . However, you can't directly simulate it under QuestaSim because you need to specify the path to the DRRA+DiMArch fabric. You need to change the automatic script according to the actual fabric RTL location in order to make the simulation work. Please check the provided automatic test script $ROOT/autotest/run.sh to know more about how to add the fabric information. After QuestaSim simulation, a register file data change event recording will also be generated.","title":"QuestaSim simulation"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#compare-the-register-file-data-change","text":"A way to verify the correct behaviour of vesyla is to compare the register file data change event recording generated from both matlab and RTL simulation. A program for the exact purpose is created while vesyla is compiled. To run the program, go to build directory and use command: 1 . / vesyla_verify $PathToMatlabRecording $PathToVsimRecording","title":"Compare the register file data change"},{"location":"Docs/ToolChain/Vesyla/Tutorial/#important-output-files","text":"Warning Update later.","title":"Important output files"}]}